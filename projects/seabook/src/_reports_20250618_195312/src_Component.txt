Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\.ts

Nome file: main.ts

import { bootstrapApplication } from '@angular/platform-browser';
import { appConfig } from './app/app.config';
import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent, appConfig)
  .catch((err) => console.error(err));

=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\.ts
.
Nome file: app.component.spec.ts
.
import { TestBed } from '@angular/core/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [AppComponent],
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it(`should have the 'seabook' title`, () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app.title).toEqual('seabook');
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(AppComponent);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, seabook');
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\.ts
.
Nome file: app.component.ts
.
import { Component } from '@angular/core';
import { SearchIsbnComponent } from './components/search-isbn/search-isbn.component';
import { RouterOutlet } from '@angular/router';
import { NavbarComponent } from './components/navbar.component';
//import { SearchBookComponent } from './components/search-book/search-book.component';

@Component({
  selector: 'app-root',
  imports: [RouterOutlet,NavbarComponent],
  templateUrl: './app.component.html',
  styleUrl: './app.component.css'
})
export class AppComponent {
  title = 'seabook';
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\.ts
.
Nome file: app.config.ts
.
import { ApplicationConfig } from '@angular/core';
import { provideRouter, withComponentInputBinding } from '@angular/router';

import { routes } from './app.routes';
import { provideAnimationsAsync } from '@angular/platform-browser/animations/async';
import { provideHttpClient } from '@angular/common/http';

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes, withComponentInputBinding()),
    provideAnimationsAsync(),
    provideHttpClient(),
    
  ],
};.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\.ts
.
Nome file: app.routes.ts
.
import { Routes } from '@angular/router';
import { SearchIsbnComponent } from './components/search-isbn/search-isbn.component';
import { BookListComponent } from './components/book-list.component';
import { BookLocalComponent } from './components/book-local.component';
import { BookList00Component } from './components/book-list00.component';
import { BookList01Component } from './components/book-list01.component';
import { Poc01Component } from './components/poc/poc01.component';
import { BookList02Component } from './components/book-list02.component';
import { RefBookListComponent } from './refactor/components/ref-book-list/ref-book-list.component';

export const routes: Routes = [
  { path: 'books/add', component: SearchIsbnComponent },
  { path: 'books/list', component: BookListComponent },
  { path: 'books/list00', component: BookList00Component },
  { path: 'books/list01', component: BookList01Component },
  { path: 'books/list02', component: BookList02Component },
  { path: 'books/local', component: BookLocalComponent },
  { path: 'poc01', component: Poc01Component },
  { path: 'books/ref/list', component: RefBookListComponent },
 // { path: '', redirectTo: 'books/list', pathMatch: 'full' }
];
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\components\.ts
.
Nome file: book-list.component.ts
.
import { Component, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Book } from '../models/book.model';
import { PageBookService } from '../services/page-book.service';
import { FormsModule } from '@angular/forms';
import { EditBookModalComponent } from './edit-book-modal.component';

@Component({
  selector: 'app-book-list',
  standalone: true,
  imports: [CommonModule, FormsModule, EditBookModalComponent],
  template: `
    <div class="container mx-auto px-4 py-8 max-w-5xl">
      <header class="mb-8">
        <h1 class="text-3xl font-bold text-gray-800 mb-2">Lista Libri</h1>
        <p class="text-gray-600">Visualizza i libri trovati e memorizzati</p>
      </header>

      <div class="flex flex-wrap gap-3 mb-6 items-center">
        <select
          class="border border-gray-300 rounded-md px-3 py-2 text-sm"
          [ngModel]="pageSize()"
          (ngModelChange)="pageSize.set($event); loadBooks()"
        >
          <option [value]="10">10</option>
          <option [value]="50">50</option>
          <option [value]="100">100</option>
          <option [value]="999">Tutti</option>
        </select>
        
        <input
          type="text"
          placeholder="Filtra per Categoria"
          class="border border-gray-300 rounded-md px-3 py-2 text-sm"
          [ngModel]="category()"
          (ngModelChange)="category.set($event); loadBooks()"
        />
        <input
          type="text"
          placeholder="Filtra per lingua b"
          class="border border-gray-300 rounded-md px-3 py-2 text-sm"
          [ngModel]="language()"
          (ngModelChange)="language.set($event); loadBooks()"
        />
        <input
          type="text"
          placeholder="Filtra per posizione"
          class="border border-gray-300 rounded-md px-3 py-2 text-sm"
          [ngModel]="mylocation()"
          (ngModelChange)="mylocation.set($event); loadBooks()"
        />
        <input
          type="text"
          placeholder="Filtra per titolo"
          class="border border-gray-300 rounded-md px-3 py-2 text-sm"
          [ngModel]="title()"
          (ngModelChange)="title.set($event); loadBooks()"
        />
        <input
          type="text"
          placeholder="Filtra per autore"
          class="border border-gray-300 rounded-md px-3 py-2 text-sm"
          [ngModel]="authors()"
          (ngModelChange)="authors.set($event); loadBooks()"
        />
        <button
          (click)="toggleFound()"
          class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition-colors"
        >
          {{ found() ? 'Solo trovati' : 'Solo non trovati' }}
        </button>
        <button
          (click)="toggleAggiornati()"
          class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition-colors"
        >
          {{
            aggiornati() === true
              ? 'Solo aggiornati'
              : aggiornati() === false
              ? 'Solo non aggiornati'
              : 'Tutti'
          }}
        </button>
        <button
          (click)="togglePdfFilter()"
          class="bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-4 rounded-md transition-colors">
          {{
            pdfFilter() === 'ALL' ? 'Libri e PDF' :
            pdfFilter() === 'ONLY' ? 'Solo PDF' : 'Con PDF'
          }}
        </button>

        <button
          (click)="resetFilters()"
          class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-medium py-2 px-4 rounded-md transition-colors"
        >
          Reset filtri
        </button>
      </div>
      <div class="flex justify-end gap-3 mb-6">
        <input
          type="text"
          [ngModel]="fileNamePrefix()"
          (ngModelChange)="fileNamePrefix.set($event)"
          class="border border-gray-300 rounded-md px-3 py-2 text-sm w-32"
          placeholder="Prefisso file"
          title="Prefisso nome file .txt"
        />
        <button
          (click)="downloadIsbnList()"
          class="bg-purple-600 hover:bg-purple-700 text-white font-medium py-2 px-4 rounded-md transition-colors"
        >
          ⬇️ Salva lista ISBN
        </button>

        <button
          (click)="downloadIsbnWithTitles()"
          class="bg-blue-400 hover:bg-blue-500 text-white font-medium py-2 px-4 rounded-md transition-colors"
        >
          ⬇️ Salva lista titoli
        </button>
      </div>

      <div *ngIf="isLoading" class="text-center py-4">
        <div class="loading mx-auto"></div>
        <p class="text-gray-600 mt-2">Caricamento...</p>
      </div>

      <div *ngIf="books.length > 0" class="bg-white rounded-lg shadow-md">
        <ul class="divide-y divide-gray-200">
          <li *ngFor="let book of books" class="p-4 flex items-center">
            <div class="flex flex-col items-center mr-4">
              <img
                *ngIf="book.coverImage"
                [src]="getCoverSrc(book)"
                (error)="onImgError($event, book)"
                alt="Copertina"
                class="book-cover rounded shadow"
              />

              <div
                *ngIf="book.only_pdf || book.with_pdf"
                class="mt-2 text-xs font-semibold px-2 py-1 rounded border"
                [ngClass]="{
                  'border-2 border-red-500 text-red-600': book.only_pdf,
                  'border-2 border-blue-500 text-blue-600':
                    !book.only_pdf && book.with_pdf
                }"
              >
                {{ book.only_pdf ? 'PDF' : 'Con PDF' }}
              </div>
            </div>

            <div class="flex-grow">
              <h2
                class="text-lg font-semibold text-gray-800 flex items-center gap-2"
              >
                {{ book.title }}
                <span
                  *ngIf="book.updatedAt"
                  class="bg-yellow-200 text-yellow-800 text-xs font-medium px-2 py-0.5 rounded"
                >
                  modificato
                </span>
              </h2>
              <p class="text-sm text-gray-700">ISBN: {{ book.isbn }}</p>
              <p class="text-sm text-gray-600">{{ book.authors }}</p>
              <p class="text-sm text-gray-500">
                Lingua: {{ book.language }} | Posizione: {{ book.mylocation }}
              </p>
              <p class="text-sm text-gray-500">
                <ng-container *ngIf="book.previewLink">
                  <a
                    [href]="book.previewLink"
                    target="_blank"
                    class="text-blue-600 underline hover:text-blue-800"
                  >
                    Anteprima
                  </a>
                </ng-container>
              </p>
              <!-- nel loop *ngFor -->
              <p>
                <!-- spunta verde se già scaricata -->
                <span
                  *ngIf="downloaded().has(book.isbn)"
                  class="text-green-600 text-xl mr-1"
                  >✔︎</span
                >

                <!-- pulsante scarica -->
                <button
                  *ngIf="book.coverImage"
                  (click)="downloadCover(book)"
                  [disabled]="downloaded().has(book.isbn)"
                  class="bg-purple-600 hover:bg-purple-700 disabled:bg-gray-400
                 text-white text-xs px-2 py-1 rounded"
                >
                  ⬇️ Scarica copertina
                </button>
              </p>

              <p class="text-sm text-gray-400">
                Ultima modifica:
                {{
                  book.updatedAt
                    ? (book.updatedAt | date : 'dd/MM/yyyy HH:mm')
                    : 'N/A'
                }}
              </p>

              <p class="text-sm text-gray-500">
                <a
                  [href]="'https://www.amazon.it/s?k=' + book.isbn"
                  target="_blank"
                  class="text-blue-600 underline hover:text-blue-800"
                >
                  Amazon
                </a>
              </p>
            </div>

            <button
              class="ml-2 bg-yellow-500 text-white text-sm px-3 py-1 rounded hover:bg-yellow-600"
              (click)="openEditModal(book)"
            >
              Modifica
            </button>
            <button
              class="ml-4 bg-red-500 text-white text-sm px-3 py-1 rounded hover:bg-red-700"
              (click)="deleteBook(book.isbn)"
            >
              Elimina
            </button>
          </li>
        </ul>
      </div>

      <div *ngIf="!isLoading && books.length === 0" class="text-center py-12">
        <p class="text-gray-500">Nessun libro trovato.</p>
      </div>
    </div>

    <app-edit-book-modal
      *ngIf="showEditModal()"
      [book]="selectedBook()!"
      (close)="closeEditModal()"
      (saved)="handleBookSaved()"
    >
    </app-edit-book-modal>
  `,
  styles: [
    `
      .book-cover {
        width: 60px;
        height: 90px;
        object-fit: cover;
      }
      .loading {
        border: 3px solid #f3f3f3;
        border-top: 3px solid #3498db;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    `,
  ],
})
export class BookListComponent {
  books: Book[] = [];
  isLoading = false;
  pageSize = signal(10);
  language = signal('');
  category = signal('inform-tech');
  mylocation = signal('');
  title = signal('');
  authors = signal('');
  found = signal(true);

  constructor(private bookService: PageBookService) {
    this.loadBooks();
  }

  loadBooks(): void {
    this.isLoading = true;
    this.bookService
      .getBooks(
        0,
        this.pageSize(),
        this.found(),
        this.language(),
        this.mylocation(),
        this.title(),
        this.authors(),
        this.category()
      )
      .subscribe({
        next: (page) => {
          let result = page.content;

          const aggiornaFiltro = this.aggiornati();
          if (aggiornaFiltro === true) {
            result = result.filter((book) => !!book.updatedAt);
          } else if (aggiornaFiltro === false) {
            result = result.filter((book) => !book.updatedAt);
          }
          if (this.pdfFilter() === 'ONLY') {
            result = result.filter(b => b.only_pdf);
          } else if (this.pdfFilter() === 'WITH') {
            result = result.filter(b => b.with_pdf && !b.only_pdf);
          }
          this.books = result;
          this.isLoading = false;
        },
        error: (err) => {
          console.error('Errore caricamento:', err);
          this.books = [];
          this.isLoading = false;
        },
      });
  }
  resetFilters(): void {
    this.language.set('');
    this.category.set('inform-tech');
    this.mylocation.set('');
    this.title.set('');
    this.authors.set('');
    this.loadBooks();
    this.found.set(true);
    this.aggiornati.set(null);
  }
  toggleFound(): void {
    this.found.set(!this.found());
    this.loadBooks();
  }
  selectedBook = signal<Book | null>(null);
  showEditModal = signal(false);

  openEditModal(book: Book): void {
    this.selectedBook.set(book);
    this.showEditModal.set(true);
  }

  closeEditModal(): void {
    this.showEditModal.set(false);
    this.selectedBook.set(null);
  }
  handleBookSaved(): void {
    this.loadBooks();
    alert('Libro aggiornato con successo');
  }

  aggiornati = signal<boolean | null>(null);
  // null = tutti, true = solo aggiornati, false = solo non aggiornati
  toggleAggiornati(): void {
    const current = this.aggiornati();
    if (current === null) {
      this.aggiornati.set(true);
    } else if (current === true) {
      this.aggiornati.set(false);
    } else {
      this.aggiornati.set(null);
    }
    this.loadBooks();
  }
  /*
downloadIsbnList(): void {
  const text = this.books.map(book => book.isbn).join('\n');
  this.downloadTextFile(text, 'lista-isbn.txt');
}*/
  downloadIsbnList(): void {
    //this.successMessage.set('File listaISBN.txt pronto per il download.');
    //setTimeout(() => this.successMessage.set(null), 3000);

    const text = this.books.map((book) => book.isbn).join('\n');
    // const numLibri = text.length;

    const now = new Date();
    const pad = (n: number) => n.toString().padStart(2, '0');
    const timestamp = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(
      now.getDate()
    )}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;

    const prefix = this.fileNamePrefix().trim() || 'Lista';
    const fileName = `${prefix}_libri_${timestamp}.txt`;

    const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    a.click();

    URL.revokeObjectURL(url);
  }
  /*
downloadIsbnWithTitles(): void {
  const text = this.books.map(book => `${book.isbn}, ${book.title}`).join('\n');
  this.downloadTextFile(text, 'isbn-titoli.txt');
}*/
  downloadIsbnWithTitles(): void {
    /*const bookList = this.books();
    if (!bookList.length) return;

    const lines = bookList.map(
      (b) => `${b.isbn}, ${b.title || 'Libro non trovato'}`
    );*/
    const bookList = this.books
      .map(
        (book) =>
          `${book.isbn}, ${book.title || 'Libro non trovato'}, ${
            book.mylocation
          },${book.only_pdf?'Solo PDF':book.with_pdf?'Cartaceo con PDF':'Cartaceo'}`
      )
      .join('\n');

    const now = new Date();
    const pad = (n: number) => n.toString().padStart(2, '0');
    const timestamp = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(
      now.getDate()
    )}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
    const prefix = this.fileNamePrefix().trim() || 'Lista';
    const fileName = `${prefix}_libri_${timestamp}_titoli.txt`;

    const blob = new Blob([bookList], {
      type: 'text/plain;charset=utf-8',
    });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    a.click();

    URL.revokeObjectURL(url);
  }
  /*
private downloadTextFile(content: string, filename: string): void {
  const blob = new Blob([content], { type: 'text/plain' });
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  window.URL.revokeObjectURL(url);
}*/
  fileNamePrefix = signal('Lista');
  //  ────────────────────────────────────────────────────────────
  downloaded = signal<Set<string>>(new Set<string>()); //  ⬅️ nuovo stato
  //  ────────────────────────────────────────────────────────────

  // inside BookListComponent
  /* libro-copertina.component.ts (o dentro BookListComponent) */

  async downloadCover(book: Book): Promise<void> {
    if (!book.coverImage) {
      return;
    }

    try {
      /* 1. fetch (servirà la cache del browser) */
      // const response = await fetch(book.coverImage, { mode: 'cors' });
      const response = await fetch(this.proxiedUrl(book)); // nessun CORS

      if (!response.ok) {
        throw new Error(`${response.status}`);
      }

      /* 2. Bytes -> Blob */
      const blob = await response.blob();

      /* 3. Object‑URL + download invisibile */
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${book.isbn}.jpg`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url); // 4. cleanup

      /* ✔︎ segna come scaricato */
      this.downloaded.update((s) => new Set(s).add(book.isbn));
    } catch (err) {
      console.error('Download copertina fallito:', err);
      alert(
        'Impossibile scaricare la copertina; prova di nuovo o verifica il link.'
      );
    }
  }

  /*
private proxiedUrl(book: Book) {
  const encoded = encodeURIComponent(book.coverImage!);
  return `http://localhost:8080/api/covers/${book.isbn}?url=${encoded}`;
}*/
  /* ------------------------------------------------------------------
   *  Restituisce il path da mostrare <img>.
   * ------------------------------------------------------------------*/
  getCoverSrc(book: Book): string {
    return `covers/${book.isbn}.jpg`;
  }

  /* quando il browser restituisce 404 */
  onImgError(ev: Event, book: Book): void {
    /* <img> che ha fallito il caricamento */
    const img = ev.target as HTMLImageElement;

    /* se abbiamo il link remoto, lo imposto */
    if (book.coverImage) {
      img.src = book.coverImage; // => ora carica da Internet
    } else {
      /* opzionale: placeholder generico */
      img.src = 'assets/placeholder-cover.svg';
    }
  }

  /* Già presente in fondo al componente – spostalo sopra se vuoi */
  private proxiedUrl(book: Book): string {
    const encoded = encodeURIComponent(book.coverImage!);
    return `http://localhost:8080/api/covers/${book.isbn}?url=${encoded}`;
  }

  pdfFilter = signal<'ALL' | 'ONLY' | 'WITH'>('ALL');

  togglePdfFilter(): void {
  const current = this.pdfFilter();
  const next = current === 'ALL' ? 'ONLY' : current === 'ONLY' ? 'WITH' : 'ALL';
  this.pdfFilter.set(next);
  this.loadBooks(); // ricarica
}

  deleteBook(isbn: string): void {
    // TODO: chiamata al BE per eliminazione libro se prevista
    this.books = this.books.filter((b) => b.isbn !== isbn);
  }
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\components\.ts
.
Nome file: book-list00.component.ts
.
import { Component, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Book } from '../models/book.model';
import { PageBookService } from '../services/page-book.service';
import { FormsModule } from '@angular/forms';
import { EditBookModalComponent } from './edit-book-modal.component';

@Component({
  selector: 'app-book-list00',
  standalone: true,
  imports: [CommonModule, FormsModule,EditBookModalComponent],
  template: `
    <div class="container mx-auto px-4 py-8 max-w-5xl">
      <header class="mb-8">
        <h1 class="text-3xl font-bold text-gray-800 mb-2">Lista Libri</h1>
        <p class="text-gray-600">Visualizza i libri trovati e memorizzati</p>
      </header>

      <div class="flex flex-wrap gap-3 mb-6 items-center">
        <select class="border border-gray-300 rounded-md px-3 py-2 text-sm"
         [ngModel]="pageSize()" 
          (ngModelChange)="pageSize.set($event); loadBooks()">
          <option [value]="10">10</option>
          <option [value]="50">50</option>
          <option [value]="100">100</option>
          <option [value]="999">Tutti</option>
        </select>
        <input
          type="text"
          placeholder="Filtra per lingua 00"
          class="border border-gray-300 rounded-md px-3 py-2 text-sm"
          [ngModel]="language()"
           (ngModelChange)="language.set($event); loadBooks()" />
        <input
          type="text"
          placeholder="Filtra per posizione"
          class="border border-gray-300 rounded-md px-3 py-2 text-sm"
          [ngModel]="mylocation()"
          (ngModelChange)="mylocation.set($event); loadBooks()" />
        <input
          type="text"
          placeholder="Filtra per titolo"
          class="border border-gray-300 rounded-md px-3 py-2 text-sm"
          [ngModel]="title()"
          (ngModelChange)="title.set($event); loadBooks()" />
        <input
          type="text"
          placeholder="Filtra per autore"
          class="border border-gray-300 rounded-md px-3 py-2 text-sm"
          [ngModel]="authors()"
          (ngModelChange)="authors.set($event); loadBooks()" />
          <button
  (click)="toggleFound()"
  class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition-colors">
  {{ found() ? 'Solo trovati' : 'Solo non trovati' }}
</button>
 <button
  (click)="toggleAggiornati()"
  class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition-colors">
{{ aggiornati() === true ? 'Solo aggiornati' : (aggiornati() === false ? 'Solo non aggiornati' : 'Tutti') }}
</button>
                      <button 
  (click)="resetFilters()" 
  class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-medium py-2 px-4 rounded-md transition-colors">
  Reset filtri
</button>
      </div>
<div class="flex justify-end gap-3 mb-6">
   <input
        type="text"
        [ngModel]="fileNamePrefix()"
        (ngModelChange)="fileNamePrefix.set($event)"
        class="border border-gray-300 rounded-md px-3 py-2 text-sm w-32"
        placeholder="Prefisso file"
        title="Prefisso nome file .txt"
      />
  <button
    (click)="downloadIsbnList()"
    class="bg-purple-600 hover:bg-purple-700 text-white font-medium py-2 px-4 rounded-md transition-colors">
    ⬇️ Salva lista ISBN
  </button>

  <button
    (click)="downloadIsbnWithTitles()"
    class="bg-blue-400 hover:bg-blue-500 text-white font-medium py-2 px-4 rounded-md transition-colors">
    ⬇️ Salva lista titoli
  </button>
</div>

      <div *ngIf="isLoading" class="text-center py-4">
        <div class="loading mx-auto"></div>
        <p class="text-gray-600 mt-2">Caricamento...</p>
      </div>

      <div *ngIf="books.length > 0" class="bg-white rounded-lg shadow-md">
        <ul class="divide-y divide-gray-200">
          <li *ngFor="let book of books" class="p-4 flex items-center">
            <img *ngIf="book.coverImage" [src]="book.coverImage" alt="Copertina" class="book-cover mr-4 rounded shadow" />
            <div class="flex-grow">
              <h2 class="text-lg font-semibold text-gray-800 flex items-center gap-2">
  {{ book.title }}
  <span *ngIf="book.updatedAt"
        class="bg-yellow-200 text-yellow-800 text-xs font-medium px-2 py-0.5 rounded">
    modificato
  </span>
</h2>
              <p class="text-sm text-gray-700">ISBN: {{ book.isbn }}</p>
              <p class="text-sm text-gray-600">{{ book.authors }}</p>
              <p class="text-sm text-gray-500">Lingua: {{ book.language }} | Posizione: {{ book.mylocation }}</p>
           <p class="text-sm text-gray-500">

  <ng-container *ngIf="book.previewLink">
    <a [href]="book.previewLink" target="_blank" class="text-blue-600 underline hover:text-blue-800">
      Anteprima
    </a>
  </ng-container>
</p>
<p class="text-sm text-gray-400">
  Ultima modifica: 
  {{ book.updatedAt ? (book.updatedAt | date:'dd/MM/yyyy HH:mm') : 'N/A' }}
</p>

<p class="text-sm text-gray-500">
  <a [href]="'https://www.amazon.it/s?k=' + book.isbn" target="_blank" class="text-blue-600 underline hover:text-blue-800">
    Amazon
  </a>
</p>
            </div>

<button
 
  class="ml-2 bg-yellow-500 text-white text-sm px-3 py-1 rounded hover:bg-yellow-600"
  (click)="openEditModal(book)">
  Modifica
</button>
            <button class="ml-4 bg-red-500 text-white text-sm px-3 py-1 rounded hover:bg-red-700" (click)="deleteBook(book.isbn)">Elimina</button>
          </li>
        </ul>
      </div>

      <div *ngIf="!isLoading && books.length === 0" class="text-center py-12">
        <p class="text-gray-500">Nessun libro trovato.</p>
      </div>
    </div>


    <app-edit-book-modal
  *ngIf="showEditModal()"
  [book]="selectedBook()!"
  (close)="closeEditModal()"
  (saved)="handleBookSaved()">
</app-edit-book-modal>

  `,
  styles: [`
    .book-cover {
      width: 60px;
      height: 90px;
      object-fit: cover;
    }
    .loading {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #3498db;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  `]
})
export class BookList00Component {
  books: Book[] = [];
  isLoading = false;
  pageSize = signal(10);
  language = signal('');
  mylocation = signal('');
  title = signal('');
  authors = signal('');
  found = signal(true);

  constructor(private bookService: PageBookService) {
    this.loadBooks();
  }

  loadBooks(): void {
    this.isLoading = true;
    this.bookService.getBooks(0, this.pageSize(),  this.found(), this.language(), this.mylocation(), this.title(), this.authors()).subscribe({
      next: page => {
        let result = page.content;

      const aggiornaFiltro = this.aggiornati();
      if (aggiornaFiltro === true) {
        result = result.filter(book => !!book.updatedAt);
      } else if (aggiornaFiltro === false) {
        result = result.filter(book => !book.updatedAt);
      }

      this.books = result;
        this.isLoading = false;
      },
      error: err => {
        console.error('Errore caricamento:', err);
        this.books = [];
        this.isLoading = false;
      }
    });
  }
resetFilters(): void {
  this.language.set('');
  this.mylocation.set('');
  this.title.set('');
  this.authors.set('');
  this.loadBooks();
  this.found.set(true);
  this.aggiornati.set(null);

}
toggleFound(): void {
  this.found.set(!this.found());
  this.loadBooks();
}
selectedBook = signal<Book | null>(null);
showEditModal = signal(false);

openEditModal(book: Book): void {
  this.selectedBook.set(book);
  this.showEditModal.set(true);
}

closeEditModal(): void {
  this.showEditModal.set(false);
  this.selectedBook.set(null);
}
handleBookSaved(): void {
  this.loadBooks();
  alert('Libro aggiornato con successo');
}

aggiornati = signal<boolean | null>(null); 
// null = tutti, true = solo aggiornati, false = solo non aggiornati
toggleAggiornati(): void {
  const current = this.aggiornati();
  if (current === null) {
    this.aggiornati.set(true);
  } else if (current === true) {
    this.aggiornati.set(false);
  } else {
    this.aggiornati.set(null);
  }
  this.loadBooks();
}
/*
downloadIsbnList(): void {
  const text = this.books.map(book => book.isbn).join('\n');
  this.downloadTextFile(text, 'lista-isbn.txt');
}*/
 downloadIsbnList(): void {
    //this.successMessage.set('File listaISBN.txt pronto per il download.');
    //setTimeout(() => this.successMessage.set(null), 3000);

   const text = this.books.map(book => book.isbn).join('\n');
   // const numLibri = text.length;

    const now = new Date();
    const pad = (n: number) => n.toString().padStart(2, '0');
    const timestamp = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(
      now.getDate()
    )}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;

    const prefix = this.fileNamePrefix().trim() || 'Lista';
    const fileName = `${prefix}_libri_${timestamp}.txt`;

    const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    a.click();

    URL.revokeObjectURL(url);
  }
  /*
downloadIsbnWithTitles(): void {
  const text = this.books.map(book => `${book.isbn}, ${book.title}`).join('\n');
  this.downloadTextFile(text, 'isbn-titoli.txt');
}*/
 downloadIsbnWithTitles(): void {
    /*const bookList = this.books();
    if (!bookList.length) return;

    const lines = bookList.map(
      (b) => `${b.isbn}, ${b.title || 'Libro non trovato'}`
    );*/
const bookList = this.books.map(book => `${book.isbn}, ${book.title || 'Libro non trovato'}, ${book.mylocation}`).join('\n');

    const now = new Date();
    const pad = (n: number) => n.toString().padStart(2, '0');
    const timestamp = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(
      now.getDate()
    )}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
    const prefix = this.fileNamePrefix().trim() || 'Lista';
    const fileName = `${prefix}_libri_${timestamp}_titoli.txt`;

    const blob = new Blob([bookList], {
      type: 'text/plain;charset=utf-8',
    });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    a.click();

    URL.revokeObjectURL(url);
  }
  /*
private downloadTextFile(content: string, filename: string): void {
  const blob = new Blob([content], { type: 'text/plain' });
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  window.URL.revokeObjectURL(url);
}*/
 fileNamePrefix = signal('Lista');

  deleteBook(isbn: string): void {
    // TODO: chiamata al BE per eliminazione libro se prevista
    this.books = this.books.filter(b => b.isbn !== isbn);
  }
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\components\.ts
.
Nome file: book-list01.component.ts
.
import { Component, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Book } from '../models/book.model';
import { PageBookService } from '../services/page-book.service';
import { FormsModule } from '@angular/forms';
import { EditBookModalComponent } from './edit-book-modal.component';

@Component({
  selector: 'app-book-list01',
  standalone: true,
  imports: [CommonModule, FormsModule,EditBookModalComponent],
  template: `
    <div class="container mx-auto px-4 py-8 max-w-5xl">
      <header class="mb-8">
        <h1 class="text-3xl font-bold text-gray-800 mb-2">Lista Libri</h1>
        <p class="text-gray-600">Visualizza i libri trovati e memorizzati</p>
      </header>

      <div class="flex flex-wrap gap-3 mb-6 items-center">
        <select class="border border-gray-300 rounded-md px-3 py-2 text-sm"
         [ngModel]="pageSize()" 
          (ngModelChange)="pageSize.set($event); loadBooks()">
          <option [value]="10">10</option>
          <option [value]="50">50</option>
          <option [value]="100">100</option>
          <option [value]="999">Tutti</option>
        </select>
        <input
          type="text"
          placeholder="Filtra per lingua 01"
          class="border border-gray-300 rounded-md px-3 py-2 text-sm"
          [ngModel]="language()"
           (ngModelChange)="language.set($event); loadBooks()" />
        <input
          type="text"
          placeholder="Filtra per posizione"
          class="border border-gray-300 rounded-md px-3 py-2 text-sm"
          [ngModel]="mylocation()"
          (ngModelChange)="mylocation.set($event); loadBooks()" />
        <input
          type="text"
          placeholder="Filtra per titolo"
          class="border border-gray-300 rounded-md px-3 py-2 text-sm"
          [ngModel]="title()"
          (ngModelChange)="title.set($event); loadBooks()" />
        <input
          type="text"
          placeholder="Filtra per autore"
          class="border border-gray-300 rounded-md px-3 py-2 text-sm"
          [ngModel]="authors()"
          (ngModelChange)="authors.set($event); loadBooks()" />
          <button
  (click)="toggleFound()"
  class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition-colors">
  {{ found() ? 'Solo trovati' : 'Solo non trovati' }}
</button>
 <button
  (click)="toggleAggiornati()"
  class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition-colors">
{{ aggiornati() === true ? 'Solo aggiornati' : (aggiornati() === false ? 'Solo non aggiornati' : 'Tutti') }}
</button>
                      <button 
  (click)="resetFilters()" 
  class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-medium py-2 px-4 rounded-md transition-colors">
  Reset filtri
</button>
      </div>
<div class="flex justify-end gap-3 mb-6">
   <input
        type="text"
        [ngModel]="fileNamePrefix()"
        (ngModelChange)="fileNamePrefix.set($event)"
        class="border border-gray-300 rounded-md px-3 py-2 text-sm w-32"
        placeholder="Prefisso file"
        title="Prefisso nome file .txt"
      />
  <button
    (click)="downloadIsbnList()"
    class="bg-purple-600 hover:bg-purple-700 text-white font-medium py-2 px-4 rounded-md transition-colors">
    ⬇️ Salva lista ISBN
  </button>

  <button
    (click)="downloadIsbnWithTitles()"
    class="bg-blue-400 hover:bg-blue-500 text-white font-medium py-2 px-4 rounded-md transition-colors">
    ⬇️ Salva lista titoli
  </button>
</div>

      <div *ngIf="isLoading" class="text-center py-4">
        <div class="loading mx-auto"></div>
        <p class="text-gray-600 mt-2">Caricamento...</p>
      </div>

      <div *ngIf="books.length > 0" class="bg-white rounded-lg shadow-md">
        <ul class="divide-y divide-gray-200">
          <li *ngFor="let book of books" class="p-4 flex items-center">
            <img *ngIf="book.coverImage" 
            [src]="buildCoverSrc(book)"
            alt="Copertina" 
            
            class="book-cover mr-4 rounded shadow" />
            <div class="flex-grow">
              <h2 class="text-lg font-semibold text-gray-800 flex items-center gap-2">
  {{ book.title }}
  <span *ngIf="book.updatedAt"
        class="bg-yellow-200 text-yellow-800 text-xs font-medium px-2 py-0.5 rounded">
    modificato
  </span>
</h2>
              <p class="text-sm text-gray-700">ISBN: {{ book.isbn }}</p>
              <p class="text-sm text-gray-600">{{ book.authors }}</p>
              <p class="text-sm text-gray-500">Lingua: {{ book.language }} | Posizione: {{ book.mylocation }}</p>
           <p class="text-sm text-gray-500">

  <ng-container *ngIf="book.previewLink">
    <a [href]="book.previewLink" target="_blank" class="text-blue-600 underline hover:text-blue-800">
      Anteprima
    </a>
  </ng-container>

</p>
<!-- nel loop *ngFor -->
<p>
  <!-- spunta verde se già scaricata -->
  <span *ngIf="downloaded().has(book.isbn)"
        class="text-green-600 text-xl mr-1">✔︎</span>

  <!-- pulsante scarica -->
  <button *ngIf="book.coverImage"
          (click)="downloadCover(book)"
          [disabled]="downloaded().has(book.isbn)"
          class="bg-purple-600 hover:bg-purple-700 disabled:bg-gray-400
                 text-white text-xs px-2 py-1 rounded">
    ⬇️ Scarica copertina
  </button>
</p>

<p class="text-sm text-gray-400">
  Ultima modifica: 
  {{ book.updatedAt ? (book.updatedAt | date:'dd/MM/yyyy HH:mm') : 'N/A' }}
</p>

<p class="text-sm text-gray-500">
  <a [href]="'https://www.amazon.it/s?k=' + book.isbn" target="_blank" class="text-blue-600 underline hover:text-blue-800">
    Amazon
  </a>
</p>
            </div>

<button
 
  class="ml-2 bg-yellow-500 text-white text-sm px-3 py-1 rounded hover:bg-yellow-600"
  (click)="openEditModal(book)">
  Modifica
</button>
            <button class="ml-4 bg-red-500 text-white text-sm px-3 py-1 rounded hover:bg-red-700" (click)="deleteBook(book.isbn)">Elimina</button>
          </li>
        </ul>
      </div>

      <div *ngIf="!isLoading && books.length === 0" class="text-center py-12">
        <p class="text-gray-500">Nessun libro trovato.</p>
      </div>
    </div>


    <app-edit-book-modal
  *ngIf="showEditModal()"
  [book]="selectedBook()!"
  (close)="closeEditModal()"
  (saved)="handleBookSaved()">
</app-edit-book-modal>

  `,
  styles: [`
    .book-cover {
      width: 60px;
      height: 90px;
      object-fit: cover;
    }
    .loading {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #3498db;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  `]
})
export class BookList01Component {
  books: Book[] = [];
  isLoading = false;
  pageSize = signal(10);
  language = signal('');
  mylocation = signal('');
  title = signal('');
  authors = signal('');
  found = signal(true);

  constructor(private bookService: PageBookService) {
    this.loadBooks();
  }

  loadBooks(): void {
    this.isLoading = true;
    this.bookService.getBooks(0, this.pageSize(),  this.found(), this.language(), this.mylocation(), this.title(), this.authors()).subscribe({
      next: page => {
        let result = page.content;

      const aggiornaFiltro = this.aggiornati();
      if (aggiornaFiltro === true) {
        result = result.filter(book => !!book.updatedAt);
      } else if (aggiornaFiltro === false) {
        result = result.filter(book => !book.updatedAt);
      }

      this.books = result;
        this.isLoading = false;
      },
      error: err => {
        console.error('Errore caricamento:', err);
        this.books = [];
        this.isLoading = false;
      }
    });
  }
resetFilters(): void {
  this.language.set('');
  this.mylocation.set('');
  this.title.set('');
  this.authors.set('');
  this.loadBooks();
  this.found.set(true);
  this.aggiornati.set(null);

}
toggleFound(): void {
  this.found.set(!this.found());
  this.loadBooks();
}
selectedBook = signal<Book | null>(null);
showEditModal = signal(false);

openEditModal(book: Book): void {
  this.selectedBook.set(book);
  this.showEditModal.set(true);
}

closeEditModal(): void {
  this.showEditModal.set(false);
  this.selectedBook.set(null);
}
handleBookSaved(): void {
  this.loadBooks();
  alert('Libro aggiornato con successo');
}

aggiornati = signal<boolean | null>(null); 
// null = tutti, true = solo aggiornati, false = solo non aggiornati
toggleAggiornati(): void {
  const current = this.aggiornati();
  if (current === null) {
    this.aggiornati.set(true);
  } else if (current === true) {
    this.aggiornati.set(false);
  } else {
    this.aggiornati.set(null);
  }
  this.loadBooks();
}
/*
downloadIsbnList(): void {
  const text = this.books.map(book => book.isbn).join('\n');
  this.downloadTextFile(text, 'lista-isbn.txt');
}*/
 downloadIsbnList(): void {
    //this.successMessage.set('File listaISBN.txt pronto per il download.');
    //setTimeout(() => this.successMessage.set(null), 3000);

   const text = this.books.map(book => book.isbn).join('\n');
   // const numLibri = text.length;

    const now = new Date();
    const pad = (n: number) => n.toString().padStart(2, '0');
    const timestamp = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(
      now.getDate()
    )}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;

    const prefix = this.fileNamePrefix().trim() || 'Lista';
    const fileName = `${prefix}_libri_${timestamp}.txt`;

    const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    a.click();

    URL.revokeObjectURL(url);
  }
  /*
downloadIsbnWithTitles(): void {
  const text = this.books.map(book => `${book.isbn}, ${book.title}`).join('\n');
  this.downloadTextFile(text, 'isbn-titoli.txt');
}*/
 downloadIsbnWithTitles(): void {
    /*const bookList = this.books();
    if (!bookList.length) return;

    const lines = bookList.map(
      (b) => `${b.isbn}, ${b.title || 'Libro non trovato'}`
    );*/
const bookList = this.books.map(book => `${book.isbn}, ${book.title || 'Libro non trovato'}, ${book.mylocation}`).join('\n');

    const now = new Date();
    const pad = (n: number) => n.toString().padStart(2, '0');
    const timestamp = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(
      now.getDate()
    )}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
    const prefix = this.fileNamePrefix().trim() || 'Lista';
    const fileName = `${prefix}_libri_${timestamp}_titoli.txt`;

    const blob = new Blob([bookList], {
      type: 'text/plain;charset=utf-8',
    });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    a.click();

    URL.revokeObjectURL(url);
  }
  /*
private downloadTextFile(content: string, filename: string): void {
  const blob = new Blob([content], { type: 'text/plain' });
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  window.URL.revokeObjectURL(url);
}*/
 fileNamePrefix = signal('Lista');
//  ────────────────────────────────────────────────────────────
downloaded = signal<Set<string>>(new Set<string>());   //  ⬅️ nuovo stato
//  ────────────────────────────────────────────────────────────

// inside BookListComponent
/* libro-copertina.component.ts (o dentro BookListComponent) */

async downloadCover(book: Book): Promise<void> {
  if (!book.coverImage) { return; }

  try {
    /* 1. fetch (servirà la cache del browser) */
   // const response = await fetch(book.coverImage, { mode: 'cors' });
    const response = await fetch(this.proxiedUrl(book));   // nessun CORS

    if (!response.ok) { throw new Error(`${response.status}`); }

    /* 2. Bytes -> Blob */
    const blob = await response.blob();

    /* 3. Object‑URL + download invisibile */
    const url  = URL.createObjectURL(blob);
    const a    = document.createElement('a');
    a.href      = url;
    a.download  = `${book.isbn}.jpg`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);     // 4. cleanup

    /* ✔︎ segna come scaricato */
    this.downloaded.update(s => new Set(s).add(book.isbn));

  } catch (err) {
    console.error('Download copertina fallito:', err);
    alert('Impossibile scaricare la copertina; prova di nuovo o verifica il link.');
  }
}


/*
private proxiedUrl(book: Book) {
  const encoded = encodeURIComponent(book.coverImage!);
  return `http://localhost:8080/api/covers/${book.isbn}?url=${encoded}`;
}*/
/* ------------------------------------------------------------------
 *  Restituisce il path da mostrare <img>.
 * ------------------------------------------------------------------*/
getCoverSrc(book: Book): string {

  return `covers/${book.isbn}.jpg`;

}

/* quando il browser restituisce 404 */
onImgError(ev: Event, book: Book): void {
  /* <img> che ha fallito il caricamento */
  const img = ev.target as HTMLImageElement;

  /* se abbiamo il link remoto, lo imposto */
  if (book.coverImage) {
    img.src = book.coverImage;      // => ora carica da Internet
  } else {
    /* opzionale: placeholder generico */
    img.src = 'assets/placeholder-cover.svg';
  }
}

/* Già presente in fondo al componente – spostalo sopra se vuoi */
private proxiedUrl(book: Book): string {
  const encoded = encodeURIComponent(book.coverImage!);
  return `http://localhost:8080/api/covers/${book.isbn}?url=${encoded}`;
}
buildCoverSrc(book: Book): string {
  // NB: dobbiamo passare il link remoto (se esiste) una sola volta (encode!)
  const remote = book.coverImage ? encodeURIComponent(book.coverImage) : '';
  return `http://localhost:8080/api/covers/${book.isbn}.jpg?remote=${remote}`;
}

  deleteBook(isbn: string): void {
    // TODO: chiamata al BE per eliminazione libro se prevista
    this.books = this.books.filter(b => b.isbn !== isbn);
  }
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\components\.ts
.
Nome file: book-list02.component.ts
.
import { Component } from '@angular/core';

@Component({
  selector: 'app-book-list02',
  imports: [],
  template: `
    <p>
      book-list02 works!
    </p>
  `,
  styles: ``
})
export class BookList02Component {

}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\components\.ts
.
Nome file: book-local.component.ts
.
// src/app/components/book-local.component.ts
import { Component, model, signal, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { LocalBookService } from '../services/local-book.service';
import { Book } from '../models/book.model';
import { from, EMPTY, timer } from 'rxjs';
import { concatMap, delayWhen, tap } from 'rxjs/operators';


@Component({
  selector: 'app-book-local',
  standalone: true,
  imports: [CommonModule, FormsModule],
  template: `
    <div class="container mx-auto max-w-3xl px-4 py-6">
      <h2 class="text-2xl font-bold mb-4">Scarica copertine da ISBN</h2>

      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 mb-2">Lista ISBN</label>

        <!-- model() = binding bidirezionale diretto -->
        <textarea
          class="w-full border border-gray-300 rounded px-3 py-2 text-sm"
          rows="6"
          [(ngModel)]="isbnInput"
          placeholder="9781234567890
9781234567891,9781234567892"></textarea>
      </div>

      <button
        class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded"
        (click)="fetchBooks()">
        Recupera & scarica copertine
      </button>

      <ul class="mt-6 space-y-2 text-sm text-gray-700" *ngIf="books().length">
        <li *ngFor="let b of books()">
          {{ b.title }}
          <span *ngIf="b.coverImage">
            – <a [href]="b.coverImage" target="_blank" class="text-blue-600 underline">copertina</a>
          </span>
        </li>
      </ul>
    </div>
  `
})
export class BookLocalComponent {
  /** binding bidirezionale  [(ngModel)]  */
  isbnInput = model<string>('');

  /** elenco di libri restituiti dal backend (readonly) */
  books = signal<Book[]>([]);

  private svc = inject(LocalBookService);

  /* 1. spezza la textarea in un array di ISBN
     2. chiama il backend
     3. salva i libri e scarica le copertine */
  fetchBooks(): void {
    const raw = this.isbnInput();
    const isbns = raw
      .split(/[\n,;\s]+/)
      .map(i => i.trim())
      .filter(Boolean);

    if (!isbns.length) return;

    this.svc.getBooksByIsbnList(isbns).subscribe({
      next: list => {
        this.books.set(list);
        this.downloadImages(list);
      },
      error: err => console.error('Errore nel caricamento libri:', err)
    });
  }

  /** scarica ogni copertina in background */
  private downloadImages(list: Book[]): void {
    list.forEach(async book => {
      if (!book.coverImage) return;

      try {
        const resp = await fetch(book.coverImage, { mode: 'cors' });
        const blob = await resp.blob();

        const url  = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href        = url;
        link.download    = `${book.isbn}.jpg`;
        link.style.display = 'none';

        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      } catch (e) {
        console.warn(`Copertina non scaricata per ISBN ${book.isbn}`, e);
      }
    });
  }
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\components\.ts
.
Nome file: edit-book-modal.component.ts
.
import { Component, Input, Output, EventEmitter, signal, inject } from '@angular/core';
import { Book } from '../models/book.model';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { PageBookService } from '../services/page-book.service';

@Component({
  selector: 'app-edit-book-modal',
  standalone: true,
  imports: [CommonModule, FormsModule],
  template: `
<div class="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50 overflow-auto">
  <div class="bg-white p-6 rounded shadow-lg w-full max-w-6xl mx-4">
    <h2 class="text-2xl font-bold mb-6 text-gray-800">Modifica libro</h2>

    <form (ngSubmit)="save()" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
      <div *ngFor="let field of fields">
        <label class="block text-sm font-medium text-gray-700 mb-1">{{ field.label }}</label>
        <input
          [type]="field.key === 'pageCount' ? 'number' : 'text'"
          class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          [ngModel]="editableBook()[field.key]"
          (ngModelChange)="updateField(field.key, $event)"
          [name]="field.key"
          [required]="!field.optional"
        />
      </div>
<!-- blocco PDF ----------------------------------------------------- -->
<div class="col-span-1 md:col-span-2 xl:col-span-3 flex gap-6">
  <!-- solo PDF -->
  <label class="inline-flex items-center gap-2 cursor-pointer">
    <input type="checkbox"
           class="h-4 w-4 text-red-600 accent-red-600"
           [checked]="onlyPdfSignal()"
           (change)="toggleOnlyPdf($event)">
    <span class="text-sm">Solo PDF</span>
  </label>

  <!-- con PDF -->
  <label class="inline-flex items-center gap-2 cursor-pointer">
    <input type="checkbox"
           class="h-4 w-4 text-blue-600 accent-blue-600"
           [checked]="withPdfSignal()"
           (change)="toggleWithPdf($event)">
    <span class="text-sm">Con PDF</span>
  </label>
</div>
<!-- --------------------------------------------------------------- -->

      <!-- Pulsanti in fondo -->
      <div class="col-span-1 md:col-span-2 xl:col-span-3 flex justify-end gap-3 mt-6">
        <button type="button"
                (click)="cancel()"
                class="px-4 py-2 bg-gray-300 rounded hover:bg-gray-400">
          Annulla
        </button>
        <button type="submit"
                class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">
          Salva
        </button>
      </div>
    </form>
  </div>
</div>

  `
})
export class EditBookModalComponent {
  /*@Input() set book(value: Book) {
      if (value) {
    this.editableBook.set({ ...value });
      }
  }*/
@Input() set book(value: Book) {
  if (value) {
    this.editableBook.set({ ...value });
    this.onlyPdfSignal.set(!!value.only_pdf);
    this.withPdfSignal.set(!!value.with_pdf);
  }
}

 //@Output() updated = new EventEmitter<Book>();
 // @Output() cancelled = new EventEmitter<void>();

  editableBook = signal<Book>({} as Book);

  fields: { key: keyof Book; label: string; optional?: boolean }[] = [
    { key: 'title', label: 'Titolo' },
    { key: 'authors', label: 'Autori' },
    { key: 'publisher', label: 'Editore' },
    { key: 'publishedDate', label: 'Anno Pubblicazione' },
    { key: 'coverImage', label: 'Copertina (URL)', optional: true },
    { key: 'description', label: 'Descrizione' },
    { key: 'pageCount', label: 'Numero Pagine' },
    { key: 'language', label: 'Lingua' },
    { key: 'categories', label: 'Categorie' },
    { key: 'previewLink', label: 'Link Amazon' },
    { key: 'mylocation', label: 'Posizione' },
  //    { key: 'only_pdf', label: 'Solo _pdf' },
 // { key: 'with_pdf', label: 'Ha _pdf' }
  ];
onlyPdfSignal   = signal(false);
withPdfSignal   = signal(false);

  updateField(key: keyof Book, value: any): void {
    this.editableBook.update(book => ({ ...book, [key]: value }));
  }

  save(): void {
    //this.updated.emit(this.editableBook());

     this.submit();
  }

  cancel(): void {
    this.close.emit();
  }
  @Output() close = new EventEmitter<void>();
@Output() saved = new EventEmitter<void>();
//@Input() book!: Book | null;

pageBookService=inject(PageBookService)
submit(): void {
 // const bookToUpdate = { ...this.editableBook(), found: true }; // forza found = true
       const bookToUpdate: Book = {
        ...this.editableBook(),
        found: true,
        only_pdf: this.onlyPdfSignal(),
        with_pdf: this.withPdfSignal()
      };
  this.pageBookService.updateBook(bookToUpdate).subscribe({
    next: () => {
      this.saved.emit();
      this.close.emit();
    },
    error: err => console.error('Errore aggiornamento:', err)
  });
}

toggleOnlyPdf(ev: Event) {
  const checked = (ev.target as HTMLInputElement).checked;
  this.onlyPdfSignal.set(checked);
  if (checked) { this.withPdfSignal.set(false); }   // non possiamo avere entrambe
}

toggleWithPdf(ev: Event) {
  const checked = (ev.target as HTMLInputElement).checked;
  this.withPdfSignal.set(checked);
  if (checked) { this.onlyPdfSignal.set(false); }
}

}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\components\.ts
.
Nome file: navbar.component.ts
.
import { Component, inject } from '@angular/core';
import { RouterModule } from '@angular/router';
import { ExportService } from '../services/export.service';

@Component({
  selector: 'app-navbar',
  standalone: true,
  imports: [RouterModule],
  template: `
    <nav class="bg-gray-800 p-4 shadow-lg">
      <div class="max-w-7xl mx-auto flex justify-between items-center">
        <h1 class="text-white text-lg font-semibold">📚 SeaBook</h1>
        <ul class="flex space-x-4">
          <li>
            <a routerLink="/books/add" routerLinkActive="text-yellow-400"
               class="text-white hover:text-yellow-400 transition font-medium">
              Inserisci
            </a>
          </li>

          <li>
            <a routerLink="books/list" routerLinkActive="text-yellow-400"
               class="text-white hover:text-yellow-400 transition font-medium">
              Leggi
            </a>
          </li>
          

          <li>
            <a routerLink="books/ref/list" routerLinkActive="text-yellow-400"
               class="text-white hover:text-yellow-400 transition font-medium">
              REF Leggi
            </a>
          </li>
<!-- 
                    <li>
            <a routerLink="poc01" routerLinkActive="text-yellow-400"
               class="text-white hover:text-yellow-400 transition font-medium">
              POC 01
            </a>
          </li>
          <li>
            <a routerLink="books/list01" routerLinkActive="text-yellow-400"
               class="text-white hover:text-yellow-400 transition font-medium">
             Leggi01
            </a>
          </li>
          <li>
            <a routerLink="books/list02" routerLinkActive="text-yellow-400"
               class="text-white hover:text-yellow-400 transition font-medium">
             Leggi02
            </a>
          </li>
          <li>
            <a routerLink="books/list00" routerLinkActive="text-yellow-400"
               class="text-white hover:text-yellow-400 transition font-medium">
             old Leggi00
            </a>
          </li>
-->
          <li>
            <a routerLink="books/local" routerLinkActive="text-yellow-400"
               class="text-white hover:text-yellow-400 transition font-medium">
              Local
            </a>
          </li>
          <li>
              <button
    (click)="downloadDump()"
    class="bg-emerald-600 hover:bg-emerald-700 text-white px-3 py-1 rounded">
    ⬇️ Dump Books
  </button>
          </li>
        </ul>
      </div>
    </nav>
  `,
  styles: []
})
export class NavbarComponent {

  private exportSvc = inject(ExportService);

  downloadDump(): void {
    this.exportSvc.dumpBooks().subscribe({
      next: sql => {
        const blob = new Blob([sql], { type: 'text/sql;charset=utf-8' });
        const url  = URL.createObjectURL(blob);
        const a    = document.createElement('a');
        a.href = url;
        a.download = 'books_dump.sql';
        a.click();
        URL.revokeObjectURL(url);
      },
      error: err => alert('Export fallito: ' + err.message)
    });
  }
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\components\poc\.ts
.
Nome file: my-signal.ts
.
export type MySignal<T> = () => T;

export type MyWriteableSignal<T> = MySignal<T> & {
    set(value: T): void;
    update(updater: (value: T) => T): void;
};

export function mySignal<T>(value: T): MyWriteableSignal<T> {
    const result = () => value;

    result.set = (newValue: T) => {
        value = newValue;
    };

    result.update = (updater: (value: T) => T) => {
        value = updater(value);
    }

    return result;
}.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\components\poc\.ts
.
Nome file: poc01.component.ts
.
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { ChangeDetectionStrategy, Component, computed, effect, signal } from '@angular/core';
import { mySignal } from './my-signal';
@Component({
  selector: 'app-poc01',
  imports: [CommonModule,FormsModule],
    changeDetection: ChangeDetectionStrategy.OnPush,

  template: `
  <div class="container mx-auto px-4 py-8 max-w-5xl">
     <header class="mb-8">
        <h1 class="text-3xl font-bold text-gray-800 mb-2">POC 01</h1>
        <p class="text-gray-600">te4st</p>
      </header>
   <input type="text" [value]="searchValue" (keyup)="searchValueChange($event)" />

<input type="text" [(ngModel)]="searchValue" />
<input
  type="text"
  [ngModel]="searchValue"
  (ngModelChange)="modelValueChange($event)"
/>
{{ searchValue }}

<br />

<form (ngSubmit)="onSearchFormSubmit()" #searchTplForm="ngForm">
  <input type="text" [(ngModel)]="searchForm.searchValue" name="searchValue" />
  <button type="submit" [disabled]="!searchTplForm.valid">Submit</button>
</form>
<br>
<h1>
    First Signal: {{firstSignal()}}
</h1>
<h1>
    Second Signal: {{secondSignal()}}
</h1>
<h1>
    Derived Signal: {{derived()}}
</h1>

<hr>
 <div class="flex flex-wrap gap-3 mb-6 items-center">
<p>
<button (click)="setSignal()">Set first signal to 10</button>
</p>
<p>
<button (click)="updateSignal()">Increment first signal</button>
</p>
 </div>
  </div>
  `,
  styles: ``
})
export class Poc01Component {
searchValue = 'Initial value';
  searchForm = {
    searchValue: 'Initial value',
  };

  modelValueChange(value: string) {
    this.searchValue = value;
  }

  searchValueChange(event: Event) {
    const value = (event.target as HTMLInputElement).value;
    this.searchValue = value;
  }

  onSearchFormSubmit(): void {
    console.log('onSearchFormSubmit', this.searchForm);
  }

   readonly firstSignal = signal(42);

  readonly secondSignal = signal('Signals');

  readonly thirdSignal = signal(10);

  readonly derived = computed(() => this.firstSignal() + this.thirdSignal());


  setSignal() {
    this.firstSignal.set(10);
    this.firstSignal.update(value => value + 1);
    this.secondSignal.set('Hello');
  }

  updateSignal() {
    this.firstSignal.update(value => value + 1);
  }

   constructor() {
    effect(() => {
      console.log('The first signal value is:', this.firstSignal());
      console.log('The second signal value is:', this.secondSignal());    
    });
  }
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\components\search-book\.ts
.
Nome file: search-book.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { SearchBookComponent } from './search-book.component';

describe('SearchBookComponent', () => {
  let component: SearchBookComponent;
  let fixture: ComponentFixture<SearchBookComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [SearchBookComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(SearchBookComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\components\search-book\.ts
.
Nome file: search-book.component.ts
.
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatRadioModule } from '@angular/material/radio';
import { MatDatepickerModule } from '@angular/material/datepicker';
import { MatNativeDateModule } from '@angular/material/core';
import { MatButtonModule } from '@angular/material/button';

@Component({
  selector: 'app-search-book',
  imports: [
    CommonModule,
    FormsModule,
    MatFormFieldModule,
    MatInputModule,
    MatSelectModule,
    MatCheckboxModule,
    MatRadioModule,
    MatDatepickerModule,
    MatNativeDateModule,
    MatButtonModule
  ],
  templateUrl: './search-book.component.html',
  styleUrl: './search-book.component.css'
})
export class SearchBookComponent {

}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\components\search-isbn\.ts
.
Nome file: search-isbn.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { SearchIsbnComponent } from './search-isbn.component';

describe('SearchIsbnComponent', () => {
  let component: SearchIsbnComponent;
  let fixture: ComponentFixture<SearchIsbnComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [SearchIsbnComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(SearchIsbnComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\components\search-isbn\.ts
.
Nome file: search-isbn.component.ts
.
import { Component, computed, inject, signal } from '@angular/core';
import { SearchBooksService } from '../../services/search-books.service';
import { Book } from '../../models/book.model';
import { SearchResultComponent } from './search-result/search-result.component';
import { CommonModule, NgIf, NgFor } from '@angular/common';
import { FormsModule } from '@angular/forms';

@Component({
  selector: 'app-search-isbn',
  imports: [CommonModule, FormsModule, SearchResultComponent],
  templateUrl: './search-isbn.component.html',
  styleUrl: './search-isbn.component.css',
})
export class SearchIsbnComponent {
  //isLoading = signal(false);
  trackByIsbn(index: number, book: Book): string {
    return book.isbn;
  }
  /*foundCount(books: Book[]): number {
  return books.filter(b => b.found).length;
}*/
  books = signal<Book[]>([]);

  foundCount = computed(() => this.books().filter((b) => b.found).length);
  isbnInput = signal('');
  isLoading = signal(false);
  errorMessage = signal<string | null>(null);
  // books$: Observable<Book[]> = signal<Observable<Book[]>>(null as any)();
  searchService = inject(SearchBooksService);
  //constructor(private searchService:SearchBooksService ) {}

  onSearchBooks(): void {
    const isbns = this.parseISBNs(this.isbnInput());
    if (isbns.length === 0) return;

    this.errorMessage.set(null);
    this.isLoading.set(true);
    this.books.set([]);
    this.hasSearched.set(true);

    this.searchService.searchBooksByIsbnList(isbns).subscribe({
      next: (results) => {
        this.books.set(results);
        this.isLoading.set(false);
      },
      error: (err) => {
        this.errorMessage.set('Errore: ' + err.message);
        this.isLoading.set(false);
      },
    });
  }

  private parseISBNs(input: string): string[] {
    return input
      .split(/[\n,;\s]+/)
      .map((i) => i.trim())
      .filter(Boolean);
  }
  successMessage = signal<string | null>(null);
  fileNamePrefix = signal('Lista');
  categoria=signal('cat_varie');
  saveIsbnList(): void {
    //this.successMessage.set('File listaISBN.txt pronto per il download.');
    //setTimeout(() => this.successMessage.set(null), 3000);

    const text = this.isbnInput();
    const lines = text.split(/\r?\n/).filter((line) => line.trim() !== '');
    const numLibri = lines.length;

    const now = new Date();
    const pad = (n: number) => n.toString().padStart(2, '0');
    const timestamp = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(
      now.getDate()
    )}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;

    const prefix = this.fileNamePrefix().trim() || 'Lista';
    const fileName = `${prefix}_${numLibri}_libri_${timestamp}.txt`;

    const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    a.click();

    URL.revokeObjectURL(url);
  }

  hasSearched = signal(false);

  saveIsbnTitlesList(): void {
    const bookList = this.books();
    if (!bookList.length) return;

    const lines = bookList.map(
      (b) => `${b.isbn}, ${b.title || 'Libro non trovato'}`
    );

    const now = new Date();
    const pad = (n: number) => n.toString().padStart(2, '0');
    const timestamp = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(
      now.getDate()
    )}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
    const prefix = this.fileNamePrefix().trim() || 'Lista';
    const fileName = `${prefix}_${bookList.length}_libri_${timestamp}_titoli.txt`;

    const blob = new Blob([lines.join('\n')], {
      type: 'text/plain;charset=utf-8',
    });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    a.click();

    URL.revokeObjectURL(url);
  }

  expandAll = signal(false);

  toggleAllDescriptions() {
    this.expandAll.set(!this.expandAll());
  }
/*
  saveToDb(): void {
    const booksToSave = this.books()
      .filter((book) => book.isbn && book.isbn.trim() !== '')
      .map((book) => ({
        ...book,
        // converto se array, altrimenti lascio com'è
        authors: Array.isArray(book.authors)
          ? book.authors.join(', ')
          : book.authors,
        categories: Array.isArray(book.categories)
          ? book.categories.join(', ')
          : book.categories,
      }));

    //booksToSave.forEach(book=>console.log(book))
    console.log(booksToSave);

    this.searchService.saveBooksToDb(booksToSave).subscribe({
      next: () =>
        this.successMessage.set('Salvataggio completato con successo.'),
      error: (err) =>
        this.errorMessage.set('Errore durante il salvataggio: ' + err.message),
    });
  }
*/



locationsAZ = [
  'A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7',
  'A01', 'A02', 'A03', 'A04', 'A05', 'A06', 'A07',
  'B01', 'B02', 'B03', 'B04', 'B05', 'B06', 'B07',
  'C01', 'C02', 'C03', 'C04', 'C05', 'C06', 'C07',
  'D01', 'D02', 'D03', 'D04', 'D05', 'D06', 'D07',
  'E01', 'E02', 'E03', 'E04', 'E05', 'E06', 'E07',
  'F01', 'F02', 'F03', 'F04', 'F05', 'F06', 'F07',
  'G01', 'G02', 'G03', 'G04', 'G05', 'G06', 'G07',
  'H01', 'H02', 'H03', 'H04', 'H05', 'H06', 'H07',
  'I01', 'I02', 'I03', 'I04', 'I05', 'I06', 'I07',
  'J01', 'J02', 'J03', 'J04', 'J05', 'J06', 'J07',
  'K01', 'K02', 'K03', 'K04', 'K05', 'K06', 'K07',
];

  locationsX = ['X01', 'X02', 'X03', 'X04', 'X05', 'X06', 'X07'];

  selectedLocation = signal('');

    onlyPdf = signal(false);  

    

  saveToDb(): void {
        const flag = this.onlyPdf();

  if (!this.selectedLocation()) {
    this.errorMessage.set('Seleziona una posizione valida');
    return;
  }
  const categ = this.categoria().trim()
const booksToSave = this.books()
  .filter(book => book.isbn && book.isbn.trim() !== '')
  .map(book => {
    const originalCategories = Array.isArray(book.categories)
      ? book.categories
      : typeof book.categories === 'string' && book.categories.trim() !== ''
        ? [book.categories.trim()]
        : [];

    return {
      ...book,
      authors: Array.isArray(book.authors) ? book.authors.join(', ') : book.authors,
      categories: [categ, ...originalCategories].join(', '), // aggiunge la categoria all'inizio
      mylocation: this.selectedLocation(),
      only_pdf: flag,
      with_pdf: false 
    };
  });

  this.searchService.saveBooksToDb(booksToSave).subscribe({
    next: () => this.successMessage.set('Salvataggio completato con successo.'),
    error: err => this.errorMessage.set('Errore durante il salvataggio: ' + err.message)
  });
}
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\components\search-isbn\search-result\.ts
.
Nome file: search-result.component.ts
.
import { Component, Input } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Book } from '../../../models/book.model';

@Component({
  selector: 'app-search-result',
  standalone: true,
  imports: [CommonModule],
  template: `
    <li class="p-6 rounded border flex gap-6 items-start shadow-sm bg-white" [class.bg-gray-100]="!book.found">
      <!-- Copertina -->
      <div class="w-24 h-32 bg-gray-200 flex items-center justify-center overflow-hidden rounded shadow-sm">
        <img *ngIf="book.coverImage; else placeholder" [src]="book.coverImage" [alt]="book.title"
             class="object-cover w-full h-full" />
        <ng-template #placeholder>
          <svg class="w-8 h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
              d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477
                 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 
                 3.332.477 4.5 1.253v13" />
          </svg>
        </ng-template>
      </div>

      <!-- Dati libro -->
      <div class="flex-1">
        <h3 class="text-lg font-bold">{{ book.title }}</h3>
        <p class="text-sm text-gray-900">{{ book.isbn }}</p>
        <p class="text-sm text-gray-500">{{ book.authors }}</p>
        <p class="text-sm text-gray-500">Pagine: {{ book.pageCount || 'N/D' }}</p>
        <p class="text-sm text-gray-500">Lingua: {{ book.language || 'N/D' }}</p>
        <p class="text-sm text-gray-500">Categoria: {{ book.categories || 'N/D' }}</p>
        <p *ngIf="book.previewLink" class="mt-1">
          <a [href]="book.previewLink" target="_blank" class="text-blue-600 hover:underline">Anteprima</a>
        </p>
        <div class="mt-2">
  <p class="text-sm text-gray-500">
    <strong>Posizione:</strong>
    <span class="text-gray-700">{{ book.mylocation || 'Non assegnata' }}</span>
  </p>
</div>

      </div>

      <!-- Descrizione -->
      <div class="w-2/5 text-sm text-gray-700 leading-relaxed" *ngIf="book.description">
        {{ expandDescription ? book.description : (book.description.length > 300 ? (book.description | slice:0:300) + '…' : book.description) }}
        <button *ngIf="book.description.length > 300"
                (click)="toggle()"
                class="block text-blue-500 text-xs mt-1 hover:underline">
          {{ expandDescription ? 'Mostra meno' : 'Mostra di più' }}
        </button>
      </div>
    </li>
  `
})
export class SearchResultComponent {
  @Input() book!: Book;
  @Input() expandDescription: boolean = false;
  private _localExpand = false;

  toggle() {
    this.expandDescription = !this.expandDescription;
  }
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\models\.ts
.
Nome file: book.model.ts
.
export interface Book {
  isbn: string;
  title: string;
  authors: string;
  publisher: string;
  publishedDate: string;
  coverImage: string | null;
  description?: string;
  pageCount?: number;
  language?: string;
  categories?: string,
  previewLink?: string;
  found: boolean;
  error?: boolean;
  searchDate?: string;
  mylocation?: string;
  updatedAt?: Date;
  only_pdf?: boolean;
  with_pdf?: boolean;

}

export interface BookPage {
  content: Book[];
  totalElements: number;
  totalPages: number;
  size: number;
  number: number;
}.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\olds\ref-edit-book-modal01\.ts
.
Nome file: ref-edit-book-modal01.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { RefEditBookModal01Component } from './ref-edit-book-modal01.component';

describe('RefEditBookModal01Component', () => {
  let component: RefEditBookModal01Component;
  let fixture: ComponentFixture<RefEditBookModal01Component>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [RefEditBookModal01Component]
    })
    .compileComponents();

    fixture = TestBed.createComponent(RefEditBookModal01Component);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\olds\ref-edit-book-modal01\.ts
.
Nome file: ref-edit-book-modal01.component.ts
.
import { Component, EventEmitter, Input, Output, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { RefBook } from '../../refactor/models/ref-book.model';
import { RefBookService } from '../../refactor/services/ref-book.service';

@Component({
  selector: 'app-ref-edit-book-modal01',
  imports: [CommonModule,FormsModule],
  templateUrl: './ref-edit-book-modal01.component.html',
  styleUrl: './ref-edit-book-modal01.component.css'
})
export class RefEditBookModal01Component {
  @Input() book!: RefBook;
  @Output() close = new EventEmitter<void>();
  @Output() saved = new EventEmitter<void>();

  readonly model = signal<Partial<RefBook>>({});

  constructor(private readonly service: RefBookService) {}

  ngOnInit() {
    this.model.set({ ...this.book });
  }

  save() {
    const toSave = { ...this.book, ...this.model() };
    this.service.updateBook(toSave).subscribe(() => {
      this.saved.emit();
      this.close.emit();
    });
  }
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\olds\ref-edit-book-modal02\.ts
.
Nome file: ref-edit-book-modal02.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { RefEditBookModal02Component } from './ref-edit-book-modal02.component';

describe('RefEditBookModal02Component', () => {
  let component: RefEditBookModal02Component;
  let fixture: ComponentFixture<RefEditBookModal02Component>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [RefEditBookModal02Component]
    })
    .compileComponents();

    fixture = TestBed.createComponent(RefEditBookModal02Component);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\olds\ref-edit-book-modal02\.ts
.
Nome file: ref-edit-book-modal02.component.ts
.
import { Component } from '@angular/core';

@Component({
  selector: 'app-ref-edit-book-modal02',
  imports: [],
  templateUrl: './ref-edit-book-modal02.component.html',
  styleUrl: './ref-edit-book-modal02.component.css'
})
export class RefEditBookModal02Component {

}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\.ts
.
Nome file: ref-pdf-badge.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { RefPdfBadgeComponent } from './ref-pdf-badge.component';

describe('RefPdfBadgeComponent', () => {
  let component: RefPdfBadgeComponent;
  let fixture: ComponentFixture<RefPdfBadgeComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [RefPdfBadgeComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(RefPdfBadgeComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\.ts
.
Nome file: ref-pdf-badge.component.ts
.
import { Component, Input } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * Badge riutilizzabile che mostra lo stato PDF di un libro.
 * - ONLY  => "Solo PDF" (rosso)
 * - WITH  => "Con PDF"  (blu)
 * Se entrambi i flag sono false/non definiti non viene renderizzato.
 */
@Component({
  selector: 'app-ref-pdf-badge',
  standalone: true,
  imports: [CommonModule],
  template: `
    <span *ngIf="only || with"
          class="mt-2 text-xs font-semibold px-2 py-1 rounded border"
          [ngClass]="{
            'border-2 border-red-500 text-red-600': only,
            'border-2 border-blue-500 text-blue-600': !only && with
          }">
      {{ only ? 'PDF' : 'Con PDF' }}
    </span>
  `,
  styles: []
})
export class RefPdfBadgeComponent {
  /** true se il libro è SOLO in PDF */
  @Input({ alias: 'only' }) only = false;
  /** true se il libro ha ANCHE un PDF (ma non è solo PDF) */
  @Input({ alias: 'with' }) with = false;
}.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-book-card\.ts
.
Nome file: ref-book-card.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { RefBookCardComponent } from './ref-book-card.component';

describe('RefBookCardComponent', () => {
  let component: RefBookCardComponent;
  let fixture: ComponentFixture<RefBookCardComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [RefBookCardComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(RefBookCardComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-book-card\.ts
.
Nome file: ref-book-card.component.ts
.
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RefBook } from '../../models/ref-book.model';
import { RefPdfBadgeComponent } from '../ref-pdf-badge.component';
@Component({
  selector: 'app-ref-book-card',
  imports: [CommonModule,RefPdfBadgeComponent],
  templateUrl: './ref-book-card.component.html',
  styleUrl: './ref-book-card.component.css'
})
export class RefBookCardComponent {
 @Input({ required: true }) book!: RefBook;
  @Input() coverDownloaded = false;

  @Output() downloadCover = new EventEmitter<RefBook>();
  @Output() edit = new EventEmitter<RefBook>();
  @Output() delete = new EventEmitter<string>();

  get coverSrc(): string {
    return `covers/${this.book.isbn}.jpg`;
  }

  onImgError(ev: Event): void {
    const img = ev.target as HTMLImageElement;
    if (this.book.coverImage) {
      img.src = this.book.coverImage;
    } else {
      img.src = 'assets/placeholder-cover.svg';
    }
  }
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-book-filters\.ts
.
Nome file: ref-book-filters.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { RefBookFiltersComponent } from './ref-book-filters.component';

describe('RefBookFiltersComponent', () => {
  let component: RefBookFiltersComponent;
  let fixture: ComponentFixture<RefBookFiltersComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [RefBookFiltersComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(RefBookFiltersComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-book-filters\.ts
.
Nome file: ref-book-filters.component.ts
.
import { Component, inject } from '@angular/core';

import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { RefBookFiltersStore } from '../../services/ref-book-filters.store';
import { FilterState } from '../../models/ref-filter-state.model';

@Component({
  selector: 'app-ref-book-filters',
  imports: [CommonModule,FormsModule],
  templateUrl: './ref-book-filters.component.html',
  styleUrl: './ref-book-filters.component.css'
})
export class RefBookFiltersComponent {
  
 private readonly store = inject(RefBookFiltersStore);
  readonly state = this.store.state;

  update(partial: Partial<FilterState>): void {
    this.store.set(partial);
  }

  reset(): void {
    this.store.set({
      language: '',
      mylocation: '',
      title: '',
      authors: '',
      found: true,
      updated: null,
      pdf: 'ALL'
    });
  }

  toggleFound(): void {
    this.update({ found: !this.state().found });
  }

  toggleUpdated(): void {
    const current = this.state().updated;
    const next = current === null ? true : current === true ? false : null;
    this.update({ updated: next });
  }

  togglePdfFilter(): void {
    const next = this.state().pdf === 'ALL' ? 'ONLY' : this.state().pdf === 'ONLY' ? 'WITH' : 'ALL';
    this.update({ pdf: next });
  }
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-book-list\.ts
.
Nome file: ref-book-list.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { RefBookListComponent } from './ref-book-list.component';

describe('RefBookListComponent', () => {
  let component: RefBookListComponent;
  let fixture: ComponentFixture<RefBookListComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [RefBookListComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(RefBookListComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-book-list\.ts
.
Nome file: ref-book-list.component.ts
.
import { Component, computed, effect, inject, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RefBookService } from '../../services/ref-book.service';
import { RefBookFiltersStore } from '../../services/ref-book-filters.store';
import { RefBook } from '../../models/ref-book.model';
import { RefBookFiltersComponent } from '../ref-book-filters/ref-book-filters.component';
import { RefBookToolbarComponent } from '../ref-book-toolbar/ref-book-toolbar.component';
import { RefBookCardComponent } from '../ref-book-card/ref-book-card.component';
import { RefEditBookModalComponent } from '../ref-edit-book-modal/ref-edit-book-modal.component';

@Component({
  selector: 'app-ref-book-list',
  imports: [
        CommonModule,
    RefBookFiltersComponent,
    RefBookToolbarComponent,
    RefBookCardComponent,
    RefEditBookModalComponent
  ],
  templateUrl: './ref-book-list.component.html',
  styleUrl: './ref-book-list.component.css'
})
export class RefBookListComponent {

  private readonly service = inject(RefBookService);
  private readonly filters = inject(RefBookFiltersStore);

  /** stato libri */
  readonly books = signal<RefBook[]>([]);
  readonly isLoading = signal(false);
  readonly downloaded = signal(new Set<string>());
  editing: RefBook | null = null;

  constructor() {
    /* ricarica ogni volta che cambiano i filtri */
    effect(() => {
      this.load(this.filters.state());
    });
  }

  private load(f: ReturnType<RefBookFiltersStore['state']>): void {
    this.isLoading.set(true);
    this.service.getBooks(f).subscribe({
      next: list => {
        this.books.set(list);
        this.isLoading.set(false);
      },
      error: () => this.isLoading.set(false)
    });
  }

  /* handler da Toolbar/Card */
  onDownloadCover(book: RefBook) { /* … */ }
  onDownloadIsbn() { /* … */ }
  onDownloadTitles() { /* … */ }
  openEdit(b: RefBook) { this.editing = b; }
  delete(isbn: string) { this.books.update(arr => arr.filter(b => b.isbn !== isbn)); }

  reload(): void {
  this.load(this.filters.state());
  this.editing = null;
}

}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-book-toolbar\.ts
.
Nome file: ref-book-toolbar.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { RefBookToolbarComponent } from './ref-book-toolbar.component';

describe('RefBookToolbarComponent', () => {
  let component: RefBookToolbarComponent;
  let fixture: ComponentFixture<RefBookToolbarComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [RefBookToolbarComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(RefBookToolbarComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-book-toolbar\.ts
.
Nome file: ref-book-toolbar.component.ts
.
import { CommonModule } from '@angular/common';
import { Component, EventEmitter, Input, Output, signal } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { RefBook } from '../../models/ref-book.model';

@Component({
  selector: 'app-ref-book-toolbar',
  imports: [CommonModule,FormsModule],
  templateUrl: './ref-book-toolbar.component.html',
  styleUrl: './ref-book-toolbar.component.css'
})
export class RefBookToolbarComponent {
 /** Lista libri correnti (input obbligatorio) */
  @Input({ required: true }) books: RefBook[] = [];

  /** Notifica al padre che è avvenuto un download (facoltativo) */
  @Output() downloadIsbn = new EventEmitter<void>();
  @Output() downloadTitles = new EventEmitter<void>();

  /** Prefisso per i file */
  readonly prefix = signal('Lista');

  /* ------------------------------------------------------------------ */
  private timestamp(): string {
    const now = new Date();
    const pad = (n: number) => n.toString().padStart(2, '0');
    return `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}` +
           `_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
  }

  private download(content: string, fileName: string): void {
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    a.click();
    URL.revokeObjectURL(url);
  }

  /* ------------------------------------------------------------------ */
  private downloadIsbnList(): void {
    const text = this.books.map(b => b.isbn).join('\n');
    const fileName = `${this.prefix().trim() || 'Lista'}_libri_${this.timestamp()}.txt`;
    this.download(text, fileName);
  }

  private downloadIsbnWithTitles(): void {
    const text = this.books.map(b => `${b.isbn}, ${b.title || 'Libro non trovato'}, ${b.mylocation ?? ''}`).join('\n');
    const fileName = `${this.prefix().trim() || 'Lista'}_libri_${this.timestamp()}_titoli.txt`;
    this.download(text, fileName);
  }

  /* Handler pubblici chiamati dal template */
  handleIsbnDownload(): void {
    if (!this.books.length) return;
    this.downloadIsbnList();
    this.downloadIsbn.emit();
  }

  handleTitlesDownload(): void {
    if (!this.books.length) return;
    this.downloadIsbnWithTitles();
    this.downloadTitles.emit();
  }

}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-edit-book-modal\.ts
.
Nome file: ref-edit-book-modal.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { RefEditBookModalComponent } from './ref-edit-book-modal.component';

describe('RefEditBookModalComponent', () => {
  let component: RefEditBookModalComponent;
  let fixture: ComponentFixture<RefEditBookModalComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [RefEditBookModalComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(RefEditBookModalComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-edit-book-modal\.ts
.
Nome file: ref-edit-book-modal.component.ts
.
import { Component, EventEmitter, Input, Output, signal, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { RefBook } from '../../models/ref-book.model';
import { RefBookService } from '../../services/ref-book.service';

@Component({
  selector: 'app-ref-edit-book-modal',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './ref-edit-book-modal.component.html',
  styleUrls: ['./ref-edit-book-modal.component.css']
})
export class RefEditBookModalComponent {
  /* ────────────────────────────────────────────────────────── */
  @Input() set book(value: RefBook | null) {
    if (value) {
      this.editableBook.set({ ...value });
      this.onlyPdfSignal.set(!!value.only_pdf);
      this.withPdfSignal.set(!!value.with_pdf);
    }
  }
  /** Emesso quando l'utente chiude senza salvare */
  @Output() close = new EventEmitter<void>();
  /** Emesso dopo il salvataggio con successo */
  @Output() saved = new EventEmitter<void>();

  /* Stato del form come signal */
  readonly editableBook = signal<RefBook>({} as RefBook);
  readonly onlyPdfSignal = signal(false);
  readonly withPdfSignal = signal(false);

  /* Campi generati dinamicamente per template a due colonne */
  readonly fields: { key: keyof RefBook; label: string; optional?: boolean }[] = [
    { key: 'title',         label: 'Titolo' },
    { key: 'authors',       label: 'Autori' },
    { key: 'publisher',     label: 'Editore' },
    { key: 'publishedDate', label: 'Anno Pubblicazione' },
    { key: 'coverImage',    label: 'Copertina (URL)', optional: true },
    { key: 'description',   label: 'Descrizione',     optional: true },
    { key: 'pageCount',     label: 'Numero Pagine',   optional: true },
    { key: 'language',      label: 'Lingua' },
    { key: 'categories',    label: 'Categorie',       optional: true },
    { key: 'previewLink',   label: 'Link Amazon',     optional: true },
    { key: 'mylocation',    label: 'Posizione',       optional: true },
  ];

  /* Servizio */
  private readonly service = inject(RefBookService);

  /* ────────────────────────────────────────────────────────── */
  updateField(key: keyof RefBook, value: any): void {
    this.editableBook.update(b => ({ ...b, [key]: value } as RefBook));
  }

  toggleOnlyPdf(ev: Event): void {
    const checked = (ev.target as HTMLInputElement).checked;
    this.onlyPdfSignal.set(checked);
    if (checked) this.withPdfSignal.set(false);
  }

  toggleWithPdf(ev: Event): void {
    const checked = (ev.target as HTMLInputElement).checked;
    this.withPdfSignal.set(checked);
    if (checked) this.onlyPdfSignal.set(false);
  }

  /* Salva libro */
  save(): void {
    const book: RefBook = {
      ...this.editableBook(),
      only_pdf: this.onlyPdfSignal(),
      with_pdf: this.withPdfSignal(),
      found: true
    } as RefBook;

    this.service.updateBook(book).subscribe({
      next: () => {
        this.saved.emit();
        this.close.emit();
      },
      error: err => console.error('Errore updateBook:', err)
    });
  }

  cancel(): void {
    this.close.emit();
  }
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\directives\.ts
.
Nome file: ref-img-fallback.directive.spec.ts
.
import { RefImgFallbackDirective } from './ref-img-fallback.directive';

describe('RefImgFallbackDirective', () => {
  it('should create an instance', () => {
    const directive = new RefImgFallbackDirective();
    expect(directive).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\directives\.ts
.
Nome file: ref-img-fallback.directive.ts
.
import { Directive } from '@angular/core';

@Directive({
  selector: '[appRefImgFallback]'
})
export class RefImgFallbackDirective {

  constructor() { }

}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\models\.ts
.
Nome file: ref-book.model.ts
.
export interface RefBook {
  isbn: string;
  title: string;
  authors: string;
  publisher: string;
  publishedDate: string;
  coverImage: string | null;
  description?: string;
  pageCount?: number;
  language?: string;
  categories?: string,
  previewLink?: string;
  found: boolean;
  error?: boolean;
  searchDate?: string;
  mylocation?: string;
  updatedAt?: Date;
  only_pdf?: boolean;
  with_pdf?: boolean;

}

export interface RefBookPage {
  content: RefBook[];
  totalElements: number;
  totalPages: number;
  size: number;
  number: number;
}.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\models\.ts
.
Nome file: ref-filter-state.model.ts
.
// refactor/models/filter-state.model.ts
export interface FilterState {
  pageSize: number;
  language: string;
  mylocation: string;
  title: string;
  authors: string;
  found: boolean;
  updated: boolean | null;
  pdf: 'ALL' | 'ONLY' | 'WITH';
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\models\.ts
.
Nome file: ref-page.model.ts
.
export interface RefPage<T> {
  content: T[];
  totalElements: number;
  totalPages: number;
  size: number;          // dimensione pagina richiesta
  number: number;        // indice pagina corrente (0-based)
  first: boolean;
  last: boolean;
  numberOfElements: number;  // quanti item effettivamente presenti in content
}.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\pipes\.ts
.
Nome file: ref-rel-datetime.pipe.spec.ts
.
import { RefRelDatetimePipe } from './ref-rel-datetime.pipe';

describe('RefRelDatetimePipe', () => {
  it('create an instance', () => {
    const pipe = new RefRelDatetimePipe();
    expect(pipe).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\pipes\.ts
.
Nome file: ref-rel-datetime.pipe.ts
.
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'refRelDatetime'
})
export class RefRelDatetimePipe implements PipeTransform {

  transform(value: unknown, ...args: unknown[]): unknown {
    return null;
  }

}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\services\.ts
.
Nome file: ref-book-filters.store.ts
.
import { Injectable, signal } from "@angular/core";
import { FilterState } from "../models/ref-filter-state.model";

@Injectable({ providedIn: 'root'})
export class RefBookFiltersStore {
  private readonly _state = signal<FilterState>({
    pageSize: 10,
    language: '',
    mylocation: '',
    title: '',
    authors: '',
    found: true,
    updated: null,
    pdf: 'ALL',
  });

  readonly state = this._state.asReadonly();

  set(partial: Partial<FilterState>) {
    this._state.update(s => ({ ...s, ...partial }));
  }
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\services\.ts
.
Nome file: ref-book.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { RefBookService } from './ref-book.service';

describe('RefBookService', () => {
  let service: RefBookService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(RefBookService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\services\.ts
.
Nome file: ref-book.service.ts
.
import { HttpClient, HttpParams } from "@angular/common/http";
import { Injectable } from "@angular/core";
import { Observable, map } from "rxjs";
import { RefBook } from "../models/ref-book.model";
import { FilterState } from "../models/ref-filter-state.model";
import { RefPage } from "../models/ref-page.model";

@Injectable({ providedIn: 'root'  })
export class RefBookService {
  constructor(private readonly http: HttpClient) {}

  getBooks(filters: FilterState): Observable<RefBook[]> {
    /*const params = new HttpParams({ fromObject: {
      page: 0,
      size: filters.pageSize,
      found: filters.found,
      language: filters.language,
      mylocation: filters.mylocation,
      title: filters.title,
      authors: filters.authors,
    }});*/
    let params = new HttpParams()
  .set('page', 0)
  .set('size', filters.pageSize)
  .set('found', filters.found);

if (filters.language) {
  params = params.set('language', filters.language);
}
if (filters.mylocation) {
  params = params.set('mylocation', filters.mylocation);
}
if (filters.title) {
  params = params.set('title', filters.title);
}
if (filters.authors) {
  params = params.set('authors', filters.authors);
}
    return this.http
      .get<RefPage<RefBook>>('/api/books', { params })
      .pipe(
        map(p => p.content),
        map(list => this.applyClientFilters(list, filters)),
      );
  }

  private applyClientFilters(list: RefBook[], f: FilterState): RefBook[] {
    return list
      .filter(b => f.updated === null ? true : !!b.updatedAt === f.updated)
      .filter(b => f.pdf === 'ALL'
        ? true
        : f.pdf === 'ONLY' ? b.only_pdf : (b.with_pdf && !b.only_pdf));
  }

  updateBook(book: RefBook) {
  return this.http.put<void>(`/api/books/${book.isbn}`, book);
}

}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\services\.ts
.
Nome file: ref-cover.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { RefCoverService } from './ref-cover.service';

describe('RefCoverService', () => {
  let service: RefCoverService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(RefCoverService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\services\.ts
.
Nome file: ref-cover.service.ts
.
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class RefCoverService {

  constructor() { }
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\services\.ts
.
Nome file: ref-file-download.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { RefFileDownloadService } from './ref-file-download.service';

describe('RefFileDownloadService', () => {
  let service: RefFileDownloadService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(RefFileDownloadService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\services\.ts
.
Nome file: ref-file-download.service.ts
.
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class RefFileDownloadService {

  constructor() { }
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\.ts
.
Nome file: ref001-pdf-badge.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { Ref001PdfBadgeComponent } from './ref001-pdf-badge.component';

describe('Ref001PdfBadgeComponent', () => {
  let component: Ref001PdfBadgeComponent;
  let fixture: ComponentFixture<Ref001PdfBadgeComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [Ref001PdfBadgeComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(Ref001PdfBadgeComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\.ts
.
Nome file: ref001-pdf-badge.component.ts
.
import { Component, Input } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * Badge riutilizzabile che mostra lo stato PDF di un libro.
 * - ONLY  => "Solo PDF" (rosso)
 * - WITH  => "Con PDF"  (blu)
 * Se entrambi i flag sono false/non definiti non viene renderizzato.
 */
@Component({
  selector: 'app-ref001-pdf-badge',
  standalone: true,
  imports: [CommonModule],
  template: `
    <span *ngIf="only || with"
          class="mt-2 text-xs font-semibold px-2 py-1 rounded border"
          [ngClass]="{
            'border-2 border-red-500 text-red-600': only,
            'border-2 border-blue-500 text-blue-600': !only && with
          }">
      {{ only ? 'PDF' : 'Con PDF' }}
    </span>
  `,
  styles: []
})
export class Ref001PdfBadgeComponent {
  /** true se il libro è SOLO in PDF */
  @Input({ alias: 'only' }) only = false;
  /** true se il libro ha ANCHE un PDF (ma non è solo PDF) */
  @Input({ alias: 'with' }) with = false;
}.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-book-card\.ts
.
Nome file: ref001-book-card.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { Ref001BookCardComponent } from './ref001-book-card.component';

describe('Ref001BookCardComponent', () => {
  let component: Ref001BookCardComponent;
  let fixture: ComponentFixture<Ref001BookCardComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [Ref001BookCardComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(Ref001BookCardComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-book-card\.ts
.
Nome file: ref001-book-card.component.ts
.
// ref001-book-card.component.ts (correzioni)
import { Component, EventEmitter, Input, Output, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Ref001Book } from '../../models/ref001-book.model';
import { Ref001PdfBadgeComponent } from '../ref001-pdf-badge.component';
import { Ref001ImgFallbackDirective } from '../../directives/ref001-img-fallback.directive';
import { Ref001RelDatetimePipe } from '../../pipes/ref001-rel-datetime.pipe';
import { Ref001CoverService } from '../../services/ref001-cover.service';

@Component({
  selector: 'app-ref001-book-card',
  standalone: true,
  imports: [
    CommonModule, 
    Ref001PdfBadgeComponent, 
    Ref001ImgFallbackDirective,
    Ref001RelDatetimePipe
  ],
  templateUrl: './ref001-book-card.component.html',
  styleUrl: './ref001-book-card.component.css'
})
export class Ref001BookCardComponent {
  @Input({ required: true }) book!: Ref001Book;
  @Input() coverDownloaded = false;

  @Output() downloadCover = new EventEmitter<Ref001Book>();
  @Output() edit = new EventEmitter<Ref001Book>();
  @Output() delete = new EventEmitter<string>();

  private readonly coverService = inject(Ref001CoverService);

  get coverSrc(): string {
    return `covers/${this.book.isbn}.jpg`;
  }

  get amazonSearchUrl(): string {
    return `https://www.amazon.it/s?k=${encodeURIComponent(this.book.isbn)}`;
  }

  onDownloadCover(): void {
    if (this.coverDownloaded) return;
    
    this.coverService.downloadCover(this.book.isbn, this.book.coverImage || undefined)
      .subscribe(blob => {
        if (blob) {
          this.coverService.saveCoverToFile(blob, this.book.isbn);
          this.downloadCover.emit(this.book);
        }
      });
  }

  onImgError(ev: Event): void {
    const img = ev.target as HTMLImageElement;
    if (this.book.coverImage && img.src !== this.book.coverImage) {
      img.src = this.book.coverImage;
    } else if (img.src !== 'assets/placeholder-cover.svg') {
      img.src = 'assets/placeholder-cover.svg';
    }
  }
}.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-book-filters\.ts
.
Nome file: ref001-book-filters.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { Ref001BookFiltersComponent } from './ref001-book-filters.component';

describe('Ref001BookFiltersComponent', () => {
  let component: Ref001BookFiltersComponent;
  let fixture: ComponentFixture<Ref001BookFiltersComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [Ref001BookFiltersComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(Ref001BookFiltersComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-book-filters\.ts
.
Nome file: ref001-book-filters.component.ts
.
import { Component } from '@angular/core';

@Component({
  selector: 'app-ref001-book-filters',
  imports: [],
  templateUrl: './ref001-book-filters.component.html',
  styleUrl: './ref001-book-filters.component.css'
})
export class Ref001BookFiltersComponent {

}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-book-list\.ts
.
Nome file: ref001-book-list.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { Ref001BookListComponent } from './ref001-book-list.component';

describe('Ref001BookListComponent', () => {
  let component: Ref001BookListComponent;
  let fixture: ComponentFixture<Ref001BookListComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [Ref001BookListComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(Ref001BookListComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-book-list\.ts
.
Nome file: ref001-book-list.component.ts
.
import { Component } from '@angular/core';

@Component({
  selector: 'app-ref001-book-list',
  imports: [],
  templateUrl: './ref001-book-list.component.html',
  styleUrl: './ref001-book-list.component.css'
})
export class Ref001BookListComponent {

}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-book-toolbar\.ts
.
Nome file: ref001-book-toolbar.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { Ref001BookToolbarComponent } from './ref001-book-toolbar.component';

describe('Ref001BookToolbarComponent', () => {
  let component: Ref001BookToolbarComponent;
  let fixture: ComponentFixture<Ref001BookToolbarComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [Ref001BookToolbarComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(Ref001BookToolbarComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-book-toolbar\.ts
.
Nome file: ref001-book-toolbar.component.ts
.
// ref001-book-toolbar.component.ts
import { CommonModule } from '@angular/common';
import { Component, EventEmitter, Input, Output, signal, inject } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { Ref001Book } from '../../models/ref001-book.model';
import { Ref001FileDownloadService } from '../../services/ref001-file-download.service';

@Component({
  selector: 'app-ref001-book-toolbar',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './ref001-book-toolbar.component.html',
  styleUrl: './ref001-book-toolbar.component.css'
})
export class Ref001BookToolbarComponent {
  @Input({ required: true }) books: Ref001Book[] = [];
  @Output() downloadIsbn = new EventEmitter<void>();
  @Output() downloadTitles = new EventEmitter<void>();

  readonly prefix = signal('Lista');
  private readonly downloadService = inject(Ref001FileDownloadService);

  get hasBooks(): boolean {
    return this.books.length > 0;
  }

  handleIsbnDownload(): void {
    if (!this.hasBooks) return;
    
    const content = this.books.map(b => b.isbn).join('\n');
    const fileName = this.downloadService.generateFileName(this.prefix(), 'isbn');
    
    this.downloadService.downloadTextFile(content, fileName);
    this.downloadIsbn.emit();
  }

  handleTitlesDownload(): void {
    if (!this.hasBooks) return;
    
    const content = this.books.map(b => 
      `${b.isbn}, ${b.title || 'Libro non trovato'}, ${b.mylocation || ''}`
    ).join('\n');
    const fileName = this.downloadService.generateFileName(this.prefix(), 'titoli');
    
    this.downloadService.downloadTextFile(content, fileName);
    this.downloadTitles.emit();
  }

  handleJsonDownload(): void {
    if (!this.hasBooks) return;
    
    const fileName = this.downloadService.generateFileName(this.prefix(), 'data', 'json');
    this.downloadService.downloadJsonFile(this.books, fileName);
  }

  handleCsvDownload(): void {
    if (!this.hasBooks) return;
    
    const csvData = this.books.map(book => ({
      ISBN: book.isbn,
      Titolo: book.title || '',
      Autori: book.authors || '',
      Editore: book.publisher || '',
      Anno: book.publishedDate || '',
      Lingua: book.language || '',
      Posizione: book.mylocation || '',
      PDF: book.only_pdf ? 'Solo PDF' : book.with_pdf ? 'Con PDF' : 'No',
      Trovato: book.found ? 'Sì' : 'No'
    }));
    
    const fileName = this.downloadService.generateFileName(this.prefix(), 'data', 'csv');
    this.downloadService.downloadCsvFile(csvData, fileName);
  }
}.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-edit-book-modal\.ts
.
Nome file: ref001-edit-book-modal.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { Ref001EditBookModalComponent } from './ref001-edit-book-modal.component';

describe('Ref001EditBookModalComponent', () => {
  let component: Ref001EditBookModalComponent;
  let fixture: ComponentFixture<Ref001EditBookModalComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [Ref001EditBookModalComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(Ref001EditBookModalComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-edit-book-modal\.ts
.
Nome file: ref001-edit-book-modal.component.ts
.
import { Component } from '@angular/core';

@Component({
  selector: 'app-ref001-edit-book-modal',
  imports: [],
  templateUrl: './ref001-edit-book-modal.component.html',
  styleUrl: './ref001-edit-book-modal.component.css'
})
export class Ref001EditBookModalComponent {

}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\directives\.ts
.
Nome file: ref001-img-fallback.directive.spec.ts
.
import { Ref001ImgFallbackDirective } from './ref001-img-fallback.directive';

describe('Ref001ImgFallbackDirective', () => {
  it('should create an instance', () => {
    const directive = new Ref001ImgFallbackDirective();
    expect(directive).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\directives\.ts
.
Nome file: ref001-img-fallback.directive.ts
.
import { Directive, ElementRef, HostListener, Input } from '@angular/core';

@Directive({
  selector: '[appRef001ImgFallback]',
  standalone: true
})
export class Ref001ImgFallbackDirective {
  @Input() appRef001ImgFallback: string = 'assets/placeholder-cover.svg';
  @Input() fallbackUrl?: string;

  constructor(private el: ElementRef<HTMLImageElement>) {}

  @HostListener('error', ['$event'])
  onError(event: Event): void {
    const img = this.el.nativeElement;
    
    // Prova prima con fallbackUrl se disponibile
    if (this.fallbackUrl && img.src !== this.fallbackUrl) {
      img.src = this.fallbackUrl;
      return;
    }
    
    // Altrimenti usa il placeholder di default
    if (img.src !== this.appRef001ImgFallback) {
      img.src = this.appRef001ImgFallback;
    }
  }
}.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\models\.ts
.
Nome file: ref001-book.model.ts
.
export interface Ref001Book {
  isbn: string;
  title: string;
  authors: string;
  publisher: string;
  publishedDate: string;
  coverImage: string | null;
  description?: string;
  pageCount?: number;
  language?: string;
  categories?: string,
  previewLink?: string;
  found: boolean;
  error?: boolean;
  searchDate?: string;
  mylocation?: string;
  updatedAt?: Date;
  only_pdf?: boolean;
  with_pdf?: boolean;

}

export interface RefBookPage {
  content: Ref001Book[];
  totalElements: number;
  totalPages: number;
  size: number;
  number: number;
}.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\models\.ts
.
Nome file: ref001-filter-state.model.ts
.
// ref001-filter-state.model.ts
export interface FilterState {
  pageSize: number;
  language: string;
  mylocation: string;
  title: string;
  authors: string;
  found: boolean;
  updated: boolean | null;
  pdf: 'ALL' | 'ONLY' | 'WITH';
}

export const DEFAULT_FILTER_STATE: FilterState = {
  pageSize: 10,
  language: '',
  mylocation: '',
  title: '',
  authors: '',
  found: true,
  updated: null,
  pdf: 'ALL',
};
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\models\.ts
.
Nome file: ref001-page.model.ts
.
export interface Ref001Page<T> {
  content: T[];
  totalElements: number;
  totalPages: number;
  size: number;          // dimensione pagina richiesta
  number: number;        // indice pagina corrente (0-based)
  first: boolean;
  last: boolean;
  numberOfElements: number;  // quanti item effettivamente presenti in content
}.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\pipes\.ts
.
Nome file: ref001-rel-datetime.pipe.spec.ts
.
import { Ref001RelDatetimePipe } from './ref001-rel-datetime.pipe';

describe('Ref001RelDatetimePipe', () => {
  it('create an instance', () => {
    const pipe = new Ref001RelDatetimePipe();
    expect(pipe).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\pipes\.ts
.
Nome file: ref001-rel-datetime.pipe.ts
.
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'refRelDatetime',
  standalone: true
})
export class Ref001RelDatetimePipe implements PipeTransform {
  transform(value: Date | string | null | undefined): string {
    if (!value) return 'N/A';
    
    const date = new Date(value);
    if (isNaN(date.getTime())) return 'Data non valida';
    
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMinutes = Math.floor(diffMs / (1000 * 60));
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    
    if (diffMinutes < 1) return 'Ora';
    if (diffMinutes < 60) return `${diffMinutes} min fa`;
    if (diffHours < 24) return `${diffHours} ore fa`;
    if (diffDays < 7) return `${diffDays} giorni fa`;
    
    return date.toLocaleDateString('it-IT', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric'
    });
  }
}.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\services\.ts
.
Nome file: ref001-book-filters.store.ts
.
// ref001-book-filters.store.ts
import { Injectable, signal } from "@angular/core";
import { FilterState, DEFAULT_FILTER_STATE } from "../models/ref001-filter-state.model";

@Injectable({ providedIn: 'root' })
export class Ref001BookFiltersStore {
  private readonly _state = signal<FilterState>({ ...DEFAULT_FILTER_STATE });

  readonly state = this._state.asReadonly();

  set(partial: Partial<FilterState>): void {
    this._state.update(s => ({ ...s, ...partial }));
  }

  reset(): void {
    this._state.set({ ...DEFAULT_FILTER_STATE });
  }

  // Metodi di utilità
  setPageSize(size: number): void {
    this.set({ pageSize: size });
  }

  setPdfFilter(filter: FilterState['pdf']): void {
    this.set({ pdf: filter });
  }

  toggleFound(): void {
    this.set({ found: !this._state().found });
  }

  toggleUpdated(): void {
    const current = this._state().updated;
    const next = current === null ? true : current === true ? false : null;
    this.set({ updated: next });
  }

  // Getter per controlli rapidi
  get isDefault(): boolean {
    const current = this._state();
    return JSON.stringify(current) === JSON.stringify(DEFAULT_FILTER_STATE);
  }
}.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\services\.ts
.
Nome file: ref001-book.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { Ref001BookService } from './ref001-book.service';

describe('Ref001BookService', () => {
  let service: Ref001BookService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(Ref001BookService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\services\.ts
.
Nome file: ref001-book.service.ts
.
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class Ref001BookService {

  constructor() { }
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\services\.ts
.
Nome file: ref001-cover.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { Ref001CoverService } from './ref001-cover.service';

describe('Ref001CoverService', () => {
  let service: Ref001CoverService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(Ref001CoverService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\services\.ts
.
Nome file: ref001-cover.service.ts
.

// ref001-cover.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, of, throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class Ref001CoverService {
  private readonly http = inject(HttpClient);

  downloadCover(isbn: string, coverUrl?: string): Observable<Blob | null> {
    if (!coverUrl) {
      return of(null);
    }

    return this.http.get(coverUrl, { responseType: 'blob' }).pipe(
      catchError(err => {
        console.error(`Errore download copertina per ISBN ${isbn}:`, err);
        return of(null);
      })
    );
  }

  saveCoverToFile(blob: Blob, isbn: string): void {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `cover_${isbn}.jpg`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  checkCoverExists(isbn: string): Observable<boolean> {
    const coverUrl = `covers/${isbn}.jpg`;
    return this.http.head(coverUrl, { observe: 'response' }).pipe(
      map(() => true),
      catchError(() => of(false))
    );
  }
}.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\services\.ts
.
Nome file: ref001-file-download.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { Ref001FileDownloadService } from './ref001-file-download.service';

describe('Ref001FileDownloadService', () => {
  let service: Ref001FileDownloadService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(Ref001FileDownloadService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\services\.ts
.
Nome file: ref001-file-download.service.ts
.
// ref001-file-download.service.ts
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class Ref001FileDownloadService {
  
  private createTimestamp(): string {
    const now = new Date();
    const pad = (n: number) => n.toString().padStart(2, '0');
    return `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}` +
           `_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
  }

  downloadTextFile(content: string, fileName: string): void {
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    this.downloadBlob(blob, fileName);
  }

  downloadJsonFile<T>(data: T, fileName: string): void {
    const content = JSON.stringify(data, null, 2);
    const blob = new Blob([content], { type: 'application/json;charset=utf-8' });
    this.downloadBlob(blob, fileName);
  }

  downloadCsvFile(data: any[], fileName: string): void {
    if (!data.length) return;
    
    const headers = Object.keys(data[0]).join(',');
    const rows = data.map(item => 
      Object.values(item).map(val => 
        typeof val === 'string' && val.includes(',') ? `"${val}"` : val
      ).join(',')
    );
    
    const csv = [headers, ...rows].join('\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
    this.downloadBlob(blob, fileName);
  }

  private downloadBlob(blob: Blob, fileName: string): void {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  generateFileName(prefix: string, suffix: string = '', extension: string = 'txt'): string {
    const cleanPrefix = prefix.trim() || 'Lista';
    const timestamp = this.createTimestamp();
    const cleanSuffix = suffix ? `_${suffix}` : '';
    return `${cleanPrefix}_${timestamp}${cleanSuffix}.${extension}`;
  }
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\services\.ts
.
Nome file: export.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { ExportService } from './export.service';

describe('ExportService', () => {
  let service: ExportService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(ExportService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\services\.ts
.
Nome file: export.service.ts
.
import { HttpClient } from '@angular/common/http';
import { inject, Injectable } from '@angular/core';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class ExportService {

    private http = inject(HttpClient);

  dumpBooks(): Observable<string> {
    return this.http.get('/api/exports/books', { responseType: 'text' });
  }
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\services\.ts
.
Nome file: local-book.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { LocalBookService } from './local-book.service';

describe('LocalBookService', () => {
  let service: LocalBookService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(LocalBookService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\services\.ts
.
Nome file: local-book.service.ts
.
import { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Book } from '../models/book.model';
import { Observable } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class LocalBookService {
  private http = inject(HttpClient);
  private apiUrl = 'http://localhost:8080/api/books/by-isbn-list';

  getBooksByIsbnList(isbns: string[]): Observable<Book[]> {
    return this.http.post<Book[]>(this.apiUrl, isbns);
  }
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\services\.ts
.
Nome file: page-book.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { PageBookService } from './page-book.service';

describe('PageBookService', () => {
  let service: PageBookService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(PageBookService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\services\.ts
.
Nome file: page-book.service.ts
.
import { HttpClient, HttpParams } from '@angular/common/http';
import { inject, Injectable } from '@angular/core';
import { Book, BookPage } from '../models/book.model';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class PageBookService {
    private http = inject(HttpClient);
  private apiUrl = 'http://localhost:8080/api/books';

    
  getBooks(
    page: number = 0,
    size: number = 10,
    found: boolean = true,
    language?: string,
    mylocation?: string,
    title?: string,
    authors?: string,
    categories:  string = 'inform-tech'   // default

  ): Observable<BookPage> {
    let params = new HttpParams()
      .set('page', page)
      .set('size', size)
      .set('found', found)
      .set('categories',  categories);   

    if (language) {
      params = params.set('language', language);
    }

    if (mylocation) {
      params = params.set('mylocation', mylocation);
    }
 if (title) {
      params = params.set('title', title);
    }

    if (authors) {
      params = params.set('authors', authors);
    }

    return this.http.get<BookPage>(this.apiUrl, { params });
  }
updateBook(book: Book): Observable<void> {
  return this.http.put<void>(`${this.apiUrl}/${book.isbn}`, book);
}

}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\services\.ts
.
Nome file: search-books.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { SearchBooksService } from './search-books.service';

describe('SearchBooksService', () => {
  let service: SearchBooksService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(SearchBooksService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\services\.ts
.
Nome file: search-books.service.ts
.
import { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Book } from '../models/book.model';
import { Observable, of, combineLatest } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { apikey } from '../utils/utils-api';

@Injectable({ providedIn: 'root' })
export class SearchBooksService {
  private http = inject(HttpClient);
  fetchBookByISBN(isbn: string): Observable<Book> {
    const cleanIsbn = isbn.replace(/[-\s]/g, '');
    const url = `https://www.googleapis.com/books/v1/volumes?q=isbn:${cleanIsbn}&key=${apikey}`;

    return this.http.get<any>(url).pipe(
      map((data) => {
        if (!data.items?.length) {
          return {
            isbn: cleanIsbn,
            title: 'Libro non trovato',
            authors: 'N/A',
            publisher: 'N/A',
            publishedDate: 'N/A',
            coverImage: null,
            found: false,
          };
        }
        const info = data.items[0].volumeInfo;
        return {
          isbn: cleanIsbn,
          title: info.title || 'Titolo sconosciuto',
          authors: info.authors?.join(', ') || 'Autore sconosciuto',
          publisher: info.publisher || 'Editore sconosciuto',
          publishedDate: info.publishedDate || 'Data sconosciuta',
          coverImage: info.imageLinks?.thumbnail || null,
          description: info.description,
          pageCount: info.pageCount,
          language: info.language,
          categories: info.categories,
          previewLink: info.previewLink || null,
          found: true,
          searchDate: new Date().toISOString(),
        };
      }),
      catchError(() =>
        of({
          isbn: cleanIsbn,
          title: 'Errore nella ricerca',
          authors: 'N/A',
          publisher: 'N/A',
          publishedDate: 'N/A',
          coverImage: null,
          found: false,
          error: true,
        })
      )
    );
  }

  searchBooksByIsbnList(isbns: string[]): Observable<Book[]> {
    return combineLatest(isbns.map((isbn) => this.fetchBookByISBN(isbn)));
  }

  saveBooksToDb(books: Book[]): Observable<any> {
  return this.http.post('http://localhost:8080/api/books', books); // Adatta l'URL al controller Spring
}

}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\utils\.ts
.
Nome file: utils-api.ts
.
//      `https://www.googleapis.com/books/v1/volumes/${bookId}?key=AIzaSyAF91IAVYR8rS5HYQquVekDF2M8dglIG7o`
export const apikey = 'AIzaSyAF91IAVYR8rS5HYQquVekDF2M8dglIG7o';
//https://www.googleapis.com/books/v1/volumes?q=isbn:9788806229000&key=AIzaSyAF91IAVYR8rS5HYQquVekDF2M8dglIG7o

export interface RespGoogle {
    kind:       string;
    totalItems: number;
    items:      BookG[];
}

export interface BookG {
    kind:       string;
    id:         string;
    etag:       string;
    selfLink:   string;
    volumeInfo: VolumeInfo;
    saleInfo:   SaleInfo;
    accessInfo: AccessInfo;
}

export interface AccessInfo {
    country:                string;
    viewability:            string;
    embeddable:             boolean;
    publicDomain:           boolean;
    textToSpeechPermission: string;
    epub:                   Epub;
    pdf:                    Epub;
    webReaderLink:          string;
    accessViewStatus:       string;
    quoteSharingAllowed:    boolean;
}

export interface Epub {
    isAvailable: boolean;
}

export interface SaleInfo {
    country:     string;
    saleability: string;
    isEbook:     boolean;
}

export interface VolumeInfo {
    title:               string;
    authors:             string[];
    publisher:           string;
    publishedDate:       string;
    description:         string;
    industryIdentifiers: IndustryIdentifier[];
    readingModes:        ReadingModes;
    pageCount:           number;
    printedPageCount:    number;
    dimensions?:          Dimensions;
    printType:           string;
    categories:          string[];
    maturityRating:      string;
    allowAnonLogging:    boolean;
    contentVersion:      string;
    panelizationSummary: PanelizationSummary;
    imageLinks:          ImageLinks;
    language:            string;
    previewLink:         string;
    infoLink:            string;
    canonicalVolumeLink: string;
}

export interface Dimensions {
    height: string;
}

export interface ImageLinks {
    smallThumbnail: string;
    thumbnail:      string;
}

export interface IndustryIdentifier {
    type:       string;
    identifier: string;
}

export interface PanelizationSummary {
    containsEpubBubbles:  boolean;
    containsImageBubbles: boolean;
}

export interface ReadingModes {
    text:  boolean;
    image: boolean;
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\utils\.ts
.
Nome file: utils.ts
.
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\.html

Nome file: index.html

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Seabook</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <app-root></app-root>
</body>
</html>

=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\.html
.
Nome file: app.component.html
.
<!--<div class="p-4">
<app-search-book></app-search-book>
</div
<div class="bg-gray-50  min-h-screen px-6 md:px-12">

<app-search-isbn></app-search-isbn>
</div>


-->

<app-navbar />
<div class="bg-gray-50 min-h-screen px-6 md:px-12">
  <router-outlet />
</div>
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\components\search-book\.html
.
Nome file: search-book.component.html
.
<form class="flex flex-col gap-4">
      <div class="flex gap-4 flex-wrap">
        <div class="flex-1">

      <mat-form-field appearance="outline" class="w-full">
        <mat-label>Text Field</mat-label>
        <input matInput type="text" [required]="false" placeholder="Enter text" />
      </mat-form-field>
            </div>
      </div>
      <div class="flex gap-4 flex-wrap">
        <div class="flex-1">

      <mat-form-field appearance="outline" class="w-full">
        <mat-label>ISBN</mat-label><textarea
  matInput
  cdkTextareaAutosize
  #autosize="cdkTextareaAutosize"
  placeholder="Enter ISBN"
  [cdkAutosizeMinRows]="3"
  [cdkAutosizeMaxRows]="150"
></textarea>

      </mat-form-field>
            </div>
      </div>
    </form>.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\components\search-isbn\.html
.
Nome file: search-isbn.component.html
.
<div class="container mx-auto px-4 py-8 max-w-5xl">
  <header class="mb-8">
    <h1 class="text-3xl font-bold text-gray-800 mb-2">
      Ricerca Libri per ISBN
    </h1>
    <p class="text-gray-600">
      Inserisci uno o più codici ISBN-13 per trovare i dettagli dei libri
    </p>
  </header>

  <div class="bg-white rounded-lg shadow-md p-6 mb-8">
    <div class="mb-4">
      <label
        for="isbnInput"
        class="block text-sm font-medium text-gray-700 mb-2"
        >Codici ISBN-13</label
      >
      <textarea
        id="isbnInput"
        [ngModel]="isbnInput()"
        (ngModelChange)="isbnInput.set($event)"
        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
        rows="4"
        placeholder="Inserisci uno o più ISBN-13 (separati da spazi, virgole o a capo)"
      ></textarea>
      <p class="mt-1 text-xs text-gray-500">
        Esempio: 9788804668237, 9788806219055, 9788804701965
      </p>
    </div>

    <div class="flex flex-wrap gap-3 items-center">
      <button
        id="searchButton"
        (click)="onSearchBooks()"
        class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition-colors"
      >
        Cerca Libri
      </button>

      <button
        id="clearButton"
        class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-medium py-2 px-4 rounded-md transition-colors"
      >
        Cancella
      </button>

      <input
        type="text"
        [ngModel]="fileNamePrefix()"
        (ngModelChange)="fileNamePrefix.set($event)"
        class="border border-gray-300 rounded-md px-3 py-2 text-sm w-32"
        placeholder="Prefisso file"
        title="Prefisso nome file .txt"
      />

      <div class="tooltip">
        <button
          id="saveIsbnListButton"
          (click)="saveIsbnList()"
          class="bg-purple-600 hover:bg-purple-700 text-white font-medium py-2 px-4 rounded-md transition-colors flex items-center"
        >
          <svg
            class="w-4 h-4 mr-2"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"
            ></path>
          </svg>
          Salva lista ISBN
        </button>
        <span class="tooltiptext">Salvataggio lista ISBN</span>
      </div>

      <button
        id="saveTitlesButton"
        (click)="saveIsbnTitlesList()"
        [disabled]="!hasSearched()"
        class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition-colors flex items-center disabled:opacity-50 disabled:cursor-not-allowed"
      >
        <svg
          class="w-4 h-4 mr-2"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"
          ></path>
        </svg>
        Salva lista titoli
      </button>
    </div>

    <!-- div class="mt-6 border-t pt-4 border-gray-200">
      <h3 class="text-sm font-semibold text-gray-700 mb-3">
        Salvataggio Database
      </h3>
      <div class="flex items-center">
        <button
          id="saveToDbButton"
          (click)="saveToDb()"
          [disabled]="!hasSearched()"
          class="bg-green-700 hover:bg-green-800 text-black font-medium py-2 px-4 rounded-md transition-colors flex items-center disabled:opacity-50 disabled:cursor-not-allowed"
        >
          <svg
            class="w-5 h-5 mr-2"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"
            />
          </svg>
          Salva su DB
        </button>
      </div>
      <p class="mt-1 text-xs text-gray-500">
        Assicurati che il server sia in esecuzione all'indirizzo specificato
      </p>
    </div -->
    <!-- Modifica dell'area "Salvataggio Database" -->
<div class="mt-6 border-t pt-4 border-gray-200">
  <h3 class="text-sm font-semibold text-gray-700 mb-3">Salvataggio Database</h3>

  <div class="flex items-center gap-2 mt-4">
  <!-- 👉 nuovo toggle -->
  <input
    id="onlyPdfToggle"
    type="checkbox"
    class="h-4 w-4 text-purple-600 border-gray-300 rounded"
    [ngModel]="onlyPdf()"
    (ngModelChange)="onlyPdf.set($event)" />

  <label for="onlyPdfToggle" class="text-sm select-none">
    Salva tutti come <strong>Solo PDF</strong>
  </label>
</div>
  <div class="flex flex-col sm:flex-row items-center gap-3">

    <select
      [ngModel]="selectedLocation()"
      (ngModelChange)="selectedLocation.set($event)"
      class="border border-gray-300 rounded-md px-3 py-2 text-sm">
      <option value="">Seleziona posizione...</option>
      <optgroup label="A-Z">
        <option *ngFor="let loc of locationsAZ" [value]="loc">{{ loc }}</option>
      </optgroup>
      <optgroup label="X">
        <option *ngFor="let loc of locationsX" [value]="loc">{{ loc }}</option>
      </optgroup>
    </select>
      <input
        type="text"
        [ngModel]="categoria()"
        (ngModelChange)="categoria.set($event)"
        class="border border-gray-300 rounded-md px-3 py-2 text-sm w-32"
        placeholder="Categoria"
        title="categoria libro"
      />
    <!-- button
      id="saveToDbButton"
      (click)="saveToDb()"
      [disabled]="!hasSearched() || !selectedLocation()"
      class="bg-green-700 hover:bg-green-800 text-black font-medium py-2 px-4 rounded-md transition-colors flex items-center disabled:opacity-50 disabled:cursor-not-allowed">
      <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
              d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
      </svg>
      Salva su DB
    </button -->
    <button
     id="saveToDbButton"
  class="mt-3 bg-green-600 hover:bg-green-700 text-white font-medium px-4 py-2 rounded  disabled:opacity-50 disabled:cursor-not-allowed"
  [disabled]="!hasSearched() || !selectedLocation()"
  (click)="saveToDb()">
  💾 Salva su DB
</button>
  </div>
  <p class="mt-1 text-xs text-gray-500">Assicurati che il server sia in esecuzione all'indirizzo specificato</p>
</div>

  </div>

  @if(isLoading()){
  <div id="loadingIndicator" class="flex justify-center items-center py-6">
    <div class="loading mr-3"></div>
    <span class="text-gray-600">Ricerca in corso...</span>
  </div>
  }
  <div
    id="errorContainer"
    class="hidden bg-red-50 border-l-4 border-red-500 p-4 mb-6"
  >
    <div class="flex">
      <div class="flex-shrink-0">
        <svg
          class="h-5 w-5 text-red-400"
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 20 20"
          fill="currentColor"
        >
          <path
            fill-rule="evenodd"
            d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z"
            clip-rule="evenodd"
          ></path>
        </svg>
      </div>
      <div class="ml-3">
        <p id="errorMessage" class="text-sm text-red-700"></p>
      </div>
    </div>
  </div>

  <div id="resultsContainer" class="hidden">
    <div class="flex flex-wrap justify-between items-center mb-4 gap-3">
      <h2 class="text-xl font-semibold text-gray-800">
        Risultati della ricerca
      </h2>
      <div class="flex items-center gap-3">
        <span
          id="resultsCount"
          class="text-sm text-gray-600 bg-gray-100 px-3 py-1 rounded-full"
        ></span>
        qui
      </div>
    </div>

    <div class="bg-white rounded-lg shadow-md overflow-hidden">
      <ul id="bookList" class="divide-y divide-gray-200"></ul>
    </div>
  </div>

  <div id="noResultsContainer" class="hidden text-center py-12">
    <svg
      class="mx-auto h-12 w-12 text-gray-400"
      fill="none"
      stroke="currentColor"
      viewBox="0 0 24 24"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        stroke-width="2"
        d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
      ></path>
    </svg>
    <h3 class="mt-2 text-lg font-medium text-gray-900">Nessun libro trovato</h3>
    <p class="mt-1 text-gray-500">Verifica gli ISBN inseriti e riprova.</p>
  </div>
</div>

<!-- Toast notifications -->
<div
  id="successToast"
  class="toast bg-green-100 border-l-4 border-green-500 text-green-700"
>
  <div class="flex items-center">
    <svg
      class="w-5 h-5 mr-2"
      fill="none"
      stroke="currentColor"
      viewBox="0 0 24 24"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        stroke-width="2"
        d="M5 13l4 4L19 7"
      ></path>
    </svg>
    <span id="successToastMessage"
      >File listaISBN.txt pronto per il download. Seleziona D:\ come
      destinazione.</span
    >
  </div>
</div>

<div
  id="errorToast"
  class="toast bg-red-100 border-l-4 border-red-500 text-red-700"
>
  <div class="flex items-center">
    <svg
      class="w-5 h-5 mr-2"
      fill="none"
      stroke="currentColor"
      viewBox="0 0 24 24"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        stroke-width="2"
        d="M6 18L18 6M6 6l12 12"
      ></path>
    </svg>
    <span id="errorToastMessage">Errore durante l'operazione.</span>
  </div>
</div>

@if (errorMessage()) {
<div class="mt-4 text-red-600">{{ errorMessage() }}</div>
} @if (books().length > 0) {

<p class="mt-4 px-6 md:px-12 text-gray-600">
  {{ foundCount() }} di {{ books().length }} trovati
</p>
<div class="mt-2 px-6 md:px-12">
  <button
    (click)="toggleAllDescriptions()"
    class="bg-indigo-500 hover:bg-indigo-600 text-black hover:text-white text-sm py-2 px-4 rounded shadow"
  >
    {{ expandAll() ? "Comprimi descrizioni" : "Espandi tutte le descrizioni" }}
  </button>
</div>

<ul class="mt-4 space-y-4 px-6 md:px-12">
  @for (book of books(); track book.isbn) {
  <app-search-result [book]="book" [expandDescription]="expandAll()" />
  }
</ul>
} @else if (!isLoading() && !errorMessage()) {
<p class="mt-4 text-gray-500">Nessun risultato trovato</p>
} @if (successMessage()) {
<div class="mt-4 bg-green-100 text-green-800 p-2 rounded shadow">
  {{ successMessage() }}
</div>
}
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\olds\ref-edit-book-modal01\.html
.
Nome file: ref-edit-book-modal01.component.html
.
<div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
  <div class="bg-white rounded-lg shadow-lg w-full max-w-2xl p-6">
    <h2 class="text-xl font-bold mb-4">Modifica libro</h2>

    <form (ngSubmit)="save()" class="grid gap-4">
      <div>
        <label class="block text-sm font-medium">Titolo</label>
        <input class="form-input w-full" [(ngModel)]="model().title" name="title" required />
      </div>

      <div>
        <label class="block text-sm font-medium">Autori</label>
        <input class="form-input w-full" [(ngModel)]="model().authors" name="authors" required />
      </div>

      <div>
        <label class="block text-sm font-medium">Lingua</label>
        <input class="form-input w-full" [(ngModel)]="model().language" name="language" />
      </div>

      <div>
        <label class="block text-sm font-medium">Posizione</label>
        <input class="form-input w-full" [(ngModel)]="model().mylocation" name="mylocation" />
      </div>

      <div>
        <label class="block text-sm font-medium">Descrizione</label>
        <textarea class="form-textarea w-full" [(ngModel)]="model().description" name="description"></textarea>
      </div>

      <div class="flex items-center space-x-4">
        <label><input type="checkbox" [(ngModel)]="model().only_pdf" name="only_pdf" /> Solo PDF</label>
        <label><input type="checkbox" [(ngModel)]="model().with_pdf" name="with_pdf" /> Con PDF</label>
      </div>

      <div class="flex justify-end gap-4 mt-6">
        <button type="button" (click)="close.emit()" class="px-4 py-2 rounded bg-gray-300 hover:bg-gray-400">Annulla</button>
        <button type="submit" class="px-4 py-2 rounded bg-blue-600 text-white hover:bg-blue-700">Salva</button>
      </div>
    </form>
  </div>
</div>
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\olds\ref-edit-book-modal02\.html
.
Nome file: ref-edit-book-modal02.component.html
.
<p>ref-edit-book-modal02 works!</p>
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-book-card\.html
.
Nome file: ref-book-card.component.html
.
   <div class="p-4 flex items-center border-b">
      <div class="flex flex-col items-center mr-4">
        <img *ngIf="book.coverImage"
             [src]="coverSrc"
             (error)="onImgError($event)"
             alt="Copertina"
             class="book-cover rounded shadow" />
        <!-- div *ngIf="book.only_pdf || book.with_pdf"
             class="mt-2 text-xs font-semibold px-2 py-1 rounded border"
             [ngClass]="{
                'border-2 border-red-500 text-red-600': book.only_pdf,
                'border-2 border-blue-500 text-blue-600': !book.only_pdf && book.with_pdf
             }">
          {{ book.only_pdf ? 'PDF' : 'Con PDF' }}
        </div-->
        <div  class="mt-2">

          <app-ref-pdf-badge
            [only]="!!book.only_pdf"
            [with]="!!book.with_pdf">
        </app-ref-pdf-badge>
        </div>
      </div>

      <div class="flex-grow">
        <h2 class="text-lg font-semibold text-gray-800 flex items-center gap-2">
          {{ book.title }}
          <span *ngIf="book.updatedAt"
                class="bg-yellow-200 text-yellow-800 text-xs font-medium px-2 py-0.5 rounded">
            modificato
          </span>
        </h2>
        <p class="text-sm text-gray-700">ISBN: {{ book.isbn }}</p>
        <p class="text-sm text-gray-600">{{ book.authors }}</p>
        <p class="text-sm text-gray-500">
          Lingua: {{ book.language }} | Posizione: {{ book.mylocation }}
        </p>
        <p class="text-sm text-gray-500">
          <a *ngIf="book.previewLink"
             [href]="book.previewLink"
             target="_blank"
             class="text-blue-600 underline hover:text-blue-800">
            Anteprima
          </a>
        </p>
        <p class="text-sm text-gray-400">
          Ultima modifica:
          {{ book.updatedAt ? (book.updatedAt | date:'dd/MM/yyyy HH:mm') : 'N/A' }}
        </p>
        <p class="text-sm text-gray-500">
          <a [href]="'https://www.amazon.it/s?k=' + book.isbn"
             target="_blank"
             class="text-blue-600 underline hover:text-blue-800">
            Amazon
          </a>
        </p>
      </div>

      <div class="flex flex-col gap-2 ml-2">
        <button class="bg-purple-600 hover:bg-purple-700 text-white text-xs px-2 py-1 rounded disabled:bg-gray-400"
                [disabled]="coverDownloaded"
                (click)="downloadCover.emit(book)">
          ⬇️ Copertina
        </button>
        <button class="bg-yellow-500 text-white text-xs px-2 py-1 rounded hover:bg-yellow-600"
                (click)="edit.emit(book)">
          Modifica
        </button>
        <button class="bg-red-500 text-white text-xs px-2 py-1 rounded hover:bg-red-700"
                (click)="delete.emit(book.isbn)">
          Elimina
        </button>
      </div>
    </div>.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-book-filters\.html
.
Nome file: ref-book-filters.component.html
.
<div class="flex flex-wrap gap-3 mb-6 items-center">
      <!-- Page size -->
      <select class="border border-gray-300 rounded-md px-3 py-2 text-sm"
              [ngModel]="state().pageSize"
              (ngModelChange)="update({ pageSize: $event })">
        <option [value]="10">10</option>
        <option [value]="50">50</option>
        <option [value]="100">100</option>
        <option [value]="999">Tutti</option>
      </select>

      <!-- Language -->
      <input type="text" placeholder="Filtra per lingua ref"
             class="border border-gray-300 rounded-md px-3 py-2 text-sm"
             [ngModel]="state().language"
             (ngModelChange)="update({ language: $event })" />

      <!-- Location -->
      <input type="text" placeholder="Filtra per posizione"
             class="border border-gray-300 rounded-md px-3 py-2 text-sm"
             [ngModel]="state().mylocation"
             (ngModelChange)="update({ mylocation: $event })" />

      <!-- Title -->
      <input type="text" placeholder="Filtra per titolo"
             class="border border-gray-300 rounded-md px-3 py-2 text-sm"
             [ngModel]="state().title"
             (ngModelChange)="update({ title: $event })" />

      <!-- Authors -->
      <input type="text" placeholder="Filtra per autore"
             class="border border-gray-300 rounded-md px-3 py-2 text-sm"
             [ngModel]="state().authors"
             (ngModelChange)="update({ authors: $event })" />

      <!-- Found toggle -->
      <button (click)="toggleFound()"
              class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition-colors">
        {{ state().found ? 'Solo trovati' : 'Solo non trovati' }}
      </button>

      <!-- Updated toggle -->
      <button (click)="toggleUpdated()"
              class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition-colors">
        {{ state().updated === true ? 'Solo aggiornati' : state().updated === false ? 'Solo non aggiornati' : 'Tutti' }}
      </button>

      <!-- PDF filter toggle -->
      <button (click)="togglePdfFilter()"
              class="bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-4 rounded-md transition-colors">
        {{ state().pdf === 'ALL' ? 'Libri e PDF' : state().pdf === 'ONLY' ? 'Solo PDF' : 'Con PDF' }}
      </button>

      <!-- Reset -->
      <button (click)="reset()"
              class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-medium py-2 px-4 rounded-md transition-colors">
        Reset filtri
      </button>
    </div>.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-book-list\.html
.
Nome file: ref-book-list.component.html
.
<div class="container mx-auto px-4 py-8 max-w-5xl">
  <h1 class="text-3xl font-bold text-gray-800 mb-6">Lista libri</h1>

  <!-- ① Filtri -->
  <app-ref-book-filters></app-ref-book-filters>

  <!-- ② Toolbar download / azioni -->
  <app-ref-book-toolbar
      [books]="books()"
      (downloadIsbn)="onDownloadIsbn()"
      (downloadTitles)="onDownloadTitles()">
  </app-ref-book-toolbar>

  <!-- ③ Lista libri -->
  <ng-container *ngIf="books().length; else empty">
    <app-ref-book-card
        *ngFor="let book of books()"
        [book]="book"
        [coverDownloaded]="downloaded().has(book.isbn)"
        (downloadCover)="onDownloadCover($event)"
        (edit)="openEdit($event)"
        (delete)="delete($event)">
    </app-ref-book-card>
  </ng-container>

  <ng-template #empty>
    <p class="text-center text-gray-500 mt-12">Nessun libro trovato.</p>
  </ng-template>
</div>

<!-- ✨ Modale  -->
<app-ref-edit-book-modal
    *ngIf="editing"
    [book]="editing"
  
    (close)="editing = null"
    (saved)="reload()">
</app-ref-edit-book-modal> >
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-book-toolbar\.html
.
Nome file: ref-book-toolbar.component.html
.
    <div class="flex justify-end gap-3 mb-6">
      <!-- Prefisso file -->
      <input type="text"
             class="border border-gray-300 rounded-md px-3 py-2 text-sm w-32"
             placeholder="Prefisso file"
             title="Prefisso nome file .txt"
             [ngModel]="prefix()"
             (ngModelChange)="prefix.set($event)"/>

      <!-- Download ISBN -->
      <button (click)="handleIsbnDownload()"
              [disabled]="!books.length"
              class="bg-purple-600 hover:bg-purple-700 disabled:bg-gray-400 text-white font-medium py-2 px-4 rounded-md transition-colors">
        ⬇️ Salva lista ISBN
      </button>

      <!-- Download titoli -->
      <button (click)="handleTitlesDownload()"
              [disabled]="!books.length"
              class="bg-blue-400 hover:bg-blue-500 disabled:bg-gray-400 text-white font-medium py-2 px-4 rounded-md transition-colors">
        ⬇️ Salva lista titoli
      </button>
    </div>.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-edit-book-modal\.html
.
Nome file: ref-edit-book-modal.component.html
.
<!-- Modale centrata con scrolling -->
<div class="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
  <div class="bg-white p-6 rounded shadow-lg w-full max-w-6xl mx-4 max-h-screen overflow-y-auto">
    <h2 class="text-2xl font-bold mb-6 text-gray-800">Modifica libro</h2>

    <form (ngSubmit)="save()" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
      <!-- Campi principali -->
      <div *ngFor="let field of fields">
        <label class="block text-sm font-medium text-gray-700 mb-1">{{ field.label }}</label>
        <input
          [type]="field.key === 'pageCount' ? 'number' : 'text'"
          class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          [ngModel]="editableBook()[field.key]"
          (ngModelChange)="updateField(field.key, $event)"
          [name]="field.key"
          [required]="!field.optional"
        />
      </div>

      <!-- Blocchi PDF -->
      <div class="col-span-1 md:col-span-2 xl:col-span-3 flex gap-6 mt-2">
        <label class="inline-flex items-center gap-2 cursor-pointer">
          <input type="checkbox"
                 class="h-4 w-4 text-red-600 accent-red-600"
                 [checked]="onlyPdfSignal()"
                 (change)="toggleOnlyPdf($event)">
          <span class="text-sm">Solo PDF</span>
        </label>
        <label class="inline-flex items-center gap-2 cursor-pointer">
          <input type="checkbox"
                 class="h-4 w-4 text-blue-600 accent-blue-600"
                 [checked]="withPdfSignal()"
                 (change)="toggleWithPdf($event)">
          <span class="text-sm">Con PDF</span>
        </label>
      </div>

      <!-- Pulsanti -->
      <div class="col-span-1 md:col-span-2 xl:col-span-3 flex justify-end gap-3 mt-6">
        <button type="button"
                (click)="cancel()"
                class="px-4 py-2 bg-gray-300 rounded hover:bg-gray-400">
          Annulla
        </button>
        <button type="submit"
                class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">
          Salva
        </button>
      </div>
    </form>
  </div>
</div>
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-book-card\.html
.
Nome file: ref001-book-card.component.html
.
<div class="p-4 flex items-center border-b hover:bg-gray-50 transition-colors">
  <div class="flex flex-col items-center mr-4">
    <img 
      *ngIf="book.coverImage || true"
      [src]="coverSrc"
      [appRef001ImgFallback]="'assets/placeholder-cover.svg'"
      [fallbackUrl]="book.coverImage || undefined"
      alt="Copertina di {{ book.title }}"
      class="book-cover rounded shadow w-16 h-20 object-cover" 
      loading="lazy" />
    
    <div class="mt-2">
      <app-ref001-pdf-badge
        [only]="!!book.only_pdf"
        [with]="!!book.with_pdf">
      </app-ref001-pdf-badge>
    </div>
  </div>

  <div class="flex-grow">
    <h2 class="text-lg font-semibold text-gray-800 flex items-center gap-2">
      {{ book.title }}
      <span *ngIf="book.updatedAt"
            class="bg-yellow-200 text-yellow-800 text-xs font-medium px-2 py-0.5 rounded">
        modificato
      </span>
    </h2>
    
    <div class="space-y-1 text-sm">
      <p class="text-gray-700">ISBN: {{ book.isbn }}</p>
      <p class="text-gray-600">{{ book.authors }}</p>
      <p class="text-gray-500">
        Lingua: {{ book.language || 'N/A' }} | Posizione: {{ book.mylocation || 'N/A' }}
      </p>
      
      <div class="flex gap-4">
        <a *ngIf="book.previewLink"
           [href]="book.previewLink"
           target="_blank"
           rel="noopener"
           class="text-blue-600 underline hover:text-blue-800">
          Anteprima
        </a>
        
        <a [href]="amazonSearchUrl"
           target="_blank"
           rel="noopener"
           class="text-blue-600 underline hover:text-blue-800">
          Amazon
        </a>
      </div>
      
      <p class="text-gray-400">
        Ultima modifica: {{ book.updatedAt | refRelDatetime }}
      </p>
    </div>
  </div>

  <div class="flex flex-col gap-2 ml-2">
    <button 
      class="bg-purple-600 hover:bg-purple-700 text-white text-xs px-2 py-1 rounded disabled:bg-gray-400 transition-colors"
      [disabled]="coverDownloaded"
      (click)="onDownloadCover()"
      [title]="coverDownloaded ? 'Copertina già scaricata' : 'Scarica copertina'">
      ⬇️ Copertina
    </button>
    
    <button 
      class="bg-yellow-500 text-white text-xs px-2 py-1 rounded hover:bg-yellow-600 transition-colors"
      (click)="edit.emit(book)"
      title="Modifica libro">
      ✏️ Modifica
    </button>
    
    <button 
      class="bg-red-500 text-white text-xs px-2 py-1 rounded hover:bg-red-700 transition-colors"
      (click)="delete.emit(book.isbn)"
      title="Elimina libro">
      🗑️ Elimina
    </button>
  </div>
</div>.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-book-filters\.html
.
Nome file: ref001-book-filters.component.html
.
<p>ref001-book-filters works!</p>
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-book-list\.html
.
Nome file: ref001-book-list.component.html
.
<p>ref001-book-list works!</p>
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-book-toolbar\.html
.
Nome file: ref001-book-toolbar.component.html
.
<p>ref001-book-toolbar works!</p>
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-edit-book-modal\.html
.
Nome file: ref001-edit-book-modal.component.html
.
<p>ref001-edit-book-modal works!</p>
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\.ts

Nome file: app.component.spec.ts

import { TestBed } from '@angular/core/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [AppComponent],
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it(`should have the 'seabook' title`, () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app.title).toEqual('seabook');
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(AppComponent);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, seabook');
  });
});

=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\components\search-book\.ts
.
Nome file: search-book.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { SearchBookComponent } from './search-book.component';

describe('SearchBookComponent', () => {
  let component: SearchBookComponent;
  let fixture: ComponentFixture<SearchBookComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [SearchBookComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(SearchBookComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\components\search-isbn\.ts
.
Nome file: search-isbn.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { SearchIsbnComponent } from './search-isbn.component';

describe('SearchIsbnComponent', () => {
  let component: SearchIsbnComponent;
  let fixture: ComponentFixture<SearchIsbnComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [SearchIsbnComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(SearchIsbnComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\olds\ref-edit-book-modal01\.ts
.
Nome file: ref-edit-book-modal01.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { RefEditBookModal01Component } from './ref-edit-book-modal01.component';

describe('RefEditBookModal01Component', () => {
  let component: RefEditBookModal01Component;
  let fixture: ComponentFixture<RefEditBookModal01Component>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [RefEditBookModal01Component]
    })
    .compileComponents();

    fixture = TestBed.createComponent(RefEditBookModal01Component);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\olds\ref-edit-book-modal02\.ts
.
Nome file: ref-edit-book-modal02.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { RefEditBookModal02Component } from './ref-edit-book-modal02.component';

describe('RefEditBookModal02Component', () => {
  let component: RefEditBookModal02Component;
  let fixture: ComponentFixture<RefEditBookModal02Component>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [RefEditBookModal02Component]
    })
    .compileComponents();

    fixture = TestBed.createComponent(RefEditBookModal02Component);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\.ts
.
Nome file: ref-pdf-badge.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { RefPdfBadgeComponent } from './ref-pdf-badge.component';

describe('RefPdfBadgeComponent', () => {
  let component: RefPdfBadgeComponent;
  let fixture: ComponentFixture<RefPdfBadgeComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [RefPdfBadgeComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(RefPdfBadgeComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-book-card\.ts
.
Nome file: ref-book-card.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { RefBookCardComponent } from './ref-book-card.component';

describe('RefBookCardComponent', () => {
  let component: RefBookCardComponent;
  let fixture: ComponentFixture<RefBookCardComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [RefBookCardComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(RefBookCardComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-book-filters\.ts
.
Nome file: ref-book-filters.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { RefBookFiltersComponent } from './ref-book-filters.component';

describe('RefBookFiltersComponent', () => {
  let component: RefBookFiltersComponent;
  let fixture: ComponentFixture<RefBookFiltersComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [RefBookFiltersComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(RefBookFiltersComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-book-list\.ts
.
Nome file: ref-book-list.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { RefBookListComponent } from './ref-book-list.component';

describe('RefBookListComponent', () => {
  let component: RefBookListComponent;
  let fixture: ComponentFixture<RefBookListComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [RefBookListComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(RefBookListComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-book-toolbar\.ts
.
Nome file: ref-book-toolbar.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { RefBookToolbarComponent } from './ref-book-toolbar.component';

describe('RefBookToolbarComponent', () => {
  let component: RefBookToolbarComponent;
  let fixture: ComponentFixture<RefBookToolbarComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [RefBookToolbarComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(RefBookToolbarComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\components\ref-edit-book-modal\.ts
.
Nome file: ref-edit-book-modal.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { RefEditBookModalComponent } from './ref-edit-book-modal.component';

describe('RefEditBookModalComponent', () => {
  let component: RefEditBookModalComponent;
  let fixture: ComponentFixture<RefEditBookModalComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [RefEditBookModalComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(RefEditBookModalComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\directives\.ts
.
Nome file: ref-img-fallback.directive.spec.ts
.
import { RefImgFallbackDirective } from './ref-img-fallback.directive';

describe('RefImgFallbackDirective', () => {
  it('should create an instance', () => {
    const directive = new RefImgFallbackDirective();
    expect(directive).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\pipes\.ts
.
Nome file: ref-rel-datetime.pipe.spec.ts
.
import { RefRelDatetimePipe } from './ref-rel-datetime.pipe';

describe('RefRelDatetimePipe', () => {
  it('create an instance', () => {
    const pipe = new RefRelDatetimePipe();
    expect(pipe).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\services\.ts
.
Nome file: ref-book.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { RefBookService } from './ref-book.service';

describe('RefBookService', () => {
  let service: RefBookService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(RefBookService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\services\.ts
.
Nome file: ref-cover.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { RefCoverService } from './ref-cover.service';

describe('RefCoverService', () => {
  let service: RefCoverService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(RefCoverService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor\services\.ts
.
Nome file: ref-file-download.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { RefFileDownloadService } from './ref-file-download.service';

describe('RefFileDownloadService', () => {
  let service: RefFileDownloadService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(RefFileDownloadService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\.ts
.
Nome file: ref001-pdf-badge.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { Ref001PdfBadgeComponent } from './ref001-pdf-badge.component';

describe('Ref001PdfBadgeComponent', () => {
  let component: Ref001PdfBadgeComponent;
  let fixture: ComponentFixture<Ref001PdfBadgeComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [Ref001PdfBadgeComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(Ref001PdfBadgeComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-book-card\.ts
.
Nome file: ref001-book-card.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { Ref001BookCardComponent } from './ref001-book-card.component';

describe('Ref001BookCardComponent', () => {
  let component: Ref001BookCardComponent;
  let fixture: ComponentFixture<Ref001BookCardComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [Ref001BookCardComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(Ref001BookCardComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-book-filters\.ts
.
Nome file: ref001-book-filters.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { Ref001BookFiltersComponent } from './ref001-book-filters.component';

describe('Ref001BookFiltersComponent', () => {
  let component: Ref001BookFiltersComponent;
  let fixture: ComponentFixture<Ref001BookFiltersComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [Ref001BookFiltersComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(Ref001BookFiltersComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-book-list\.ts
.
Nome file: ref001-book-list.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { Ref001BookListComponent } from './ref001-book-list.component';

describe('Ref001BookListComponent', () => {
  let component: Ref001BookListComponent;
  let fixture: ComponentFixture<Ref001BookListComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [Ref001BookListComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(Ref001BookListComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-book-toolbar\.ts
.
Nome file: ref001-book-toolbar.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { Ref001BookToolbarComponent } from './ref001-book-toolbar.component';

describe('Ref001BookToolbarComponent', () => {
  let component: Ref001BookToolbarComponent;
  let fixture: ComponentFixture<Ref001BookToolbarComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [Ref001BookToolbarComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(Ref001BookToolbarComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\components\ref001-edit-book-modal\.ts
.
Nome file: ref001-edit-book-modal.component.spec.ts
.
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { Ref001EditBookModalComponent } from './ref001-edit-book-modal.component';

describe('Ref001EditBookModalComponent', () => {
  let component: Ref001EditBookModalComponent;
  let fixture: ComponentFixture<Ref001EditBookModalComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [Ref001EditBookModalComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(Ref001EditBookModalComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\directives\.ts
.
Nome file: ref001-img-fallback.directive.spec.ts
.
import { Ref001ImgFallbackDirective } from './ref001-img-fallback.directive';

describe('Ref001ImgFallbackDirective', () => {
  it('should create an instance', () => {
    const directive = new Ref001ImgFallbackDirective();
    expect(directive).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\pipes\.ts
.
Nome file: ref001-rel-datetime.pipe.spec.ts
.
import { Ref001RelDatetimePipe } from './ref001-rel-datetime.pipe';

describe('Ref001RelDatetimePipe', () => {
  it('create an instance', () => {
    const pipe = new Ref001RelDatetimePipe();
    expect(pipe).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\services\.ts
.
Nome file: ref001-book.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { Ref001BookService } from './ref001-book.service';

describe('Ref001BookService', () => {
  let service: Ref001BookService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(Ref001BookService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\services\.ts
.
Nome file: ref001-cover.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { Ref001CoverService } from './ref001-cover.service';

describe('Ref001CoverService', () => {
  let service: Ref001CoverService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(Ref001CoverService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\refactor001\services\.ts
.
Nome file: ref001-file-download.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { Ref001FileDownloadService } from './ref001-file-download.service';

describe('Ref001FileDownloadService', () => {
  let service: Ref001FileDownloadService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(Ref001FileDownloadService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\services\.ts
.
Nome file: export.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { ExportService } from './export.service';

describe('ExportService', () => {
  let service: ExportService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(ExportService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\services\.ts
.
Nome file: local-book.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { LocalBookService } from './local-book.service';

describe('LocalBookService', () => {
  let service: LocalBookService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(LocalBookService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\services\.ts
.
Nome file: page-book.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { PageBookService } from './page-book.service';

describe('PageBookService', () => {
  let service: PageBookService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(PageBookService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
Directory e tipo: \ang2025_portfolio\angular2025_FEB\projects\seabook\src\app\services\.ts
.
Nome file: search-books.service.spec.ts
.
import { TestBed } from '@angular/core/testing';

import { SearchBooksService } from './search-books.service';

describe('SearchBooksService', () => {
  let service: SearchBooksService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(SearchBooksService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
.
=============================================================
